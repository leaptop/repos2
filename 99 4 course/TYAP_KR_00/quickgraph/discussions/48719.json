[
  {
    "Id": "162700",
    "ThreadId": "48719",
    "Html": "<p dir=ltr style=\"margin-right:0px\">Hello, I am using <span style=\"text-decoration:underline\">QuickGraph for .Net2.0</span>  and can not find the shortest path cause i get a compiling error (at the bolded line):<br>\r\nSomething like &quot;<em>cannot convert</em> argument 2 from Generic.<span style=\"text-decoration:underline\">Dictionary</span>&lt;... to QuickGraph.<span style=\"text-decoration:underline\">Func</span>...<br>\r\nAfter searching around i found the following:<br>\r\nFrom: pelikhan<br>\r\nDijkstra now takes a delegate that maps a TEdge to a double (i.e. map from edges to their cost). Implicitely, this was done by calling the indexer of the dictionary. Simply pass the following in your case: e =&gt; edgeCost[e]<br>\r\nI can not interpret the answer! Can I use this term directly in c# with .Net2.0?<br>\r\nI am currently not very familiar with the new .net features like generics and perhaps the syntax e=&gt;....<br>\r\nCan someone pleeeeeaaaaseee help me to find the shortest path from &quot;A&quot; to &quot;B&quot; (there are some more commandos missing like observer,...)?<br>\r\nBelow the code i found in the discussion forum:<br>\r\n<br>\r\nAdjacencyGraph&lt;string, Edge&lt;string&gt;&gt; graph = new AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt;(true);<br>\r\n// Add some vertices to the graph<br>\r\ngraph.AddVertex(&quot;A&quot;);<br>\r\ngraph.AddVertex(&quot;B&quot;);<br>\r\n// Create the edges<br>\r\nEdge&lt;string&gt; a_b = new Edge&lt;string&gt;(&quot;A&quot;, &quot;B&quot;);<br>\r\n// Add the edges<br>\r\ngraph.AddEdge(a_b);<br>\r\n// Define some weights to the edges<br>\r\nDictionary&lt;Edge&lt;string&gt;, double&gt; edgeCost = new Dictionary&lt;Edge&lt;string&gt;, double&gt;(graph.EdgeCount);<br>\r\nedgeCost.Add(a_b, 4);<br>\r\n// We want to use Dijkstra on this graph<br>\r\n<strong>DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt; dijkstra = new DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt;(graph, edgeCost);<br>\r\n</strong><br>\r\n<br>\r\nTHANK YOU!<br>\r\n<br>\r\nStephan</p>\r\n",
    "PostedDate": "2009-02-27T03:57:38.453-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "162864",
    "ThreadId": "48719",
    "Html": "You need to pass a delegate to the constructor. In this case, the indexer of the dictionary edgeCount. Since the indexer is not really accessible from C#, you can use the AlgorithmExtensions.GetIndexer method:<br>\r\n<br>\r\n<blockquote><strong>using QuickGraph.Algorithms;</strong><br>\r\n<strong><strong>var dijkstra = new DijkstraShortestPathAlgorithm&lt;string,\r\nEdge&lt;string&gt;&gt;(graph,&nbsp; edgeCost.GetIndexer());</strong></strong></blockquote>\r\n",
    "PostedDate": "2009-02-27T11:42:56.937-08:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "163394",
    "ThreadId": "48719",
    "Html": "<p>Thanks! Now it works! My complete example for other guys:     <br>\r\n<br>\r\nAdjacencyGraph&lt;string, Edge&lt;string&gt;&gt; graph = new AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt;(true);</p>\r\n<p>            // Add some cities to the graph<br>\r\n            graph.AddVertex(&quot;A&quot;);<br>\r\n            graph.AddVertex(&quot;B&quot;);<br>\r\n            graph.AddVertex(&quot;C&quot;);<br>\r\n            graph.AddVertex(&quot;D&quot;);<br>\r\n            graph.AddVertex(&quot;E&quot;);<br>\r\n            graph.AddVertex(&quot;F&quot;);<br>\r\n            graph.AddVertex(&quot;G&quot;);<br>\r\n            graph.AddVertex(&quot;H&quot;);<br>\r\n            graph.AddVertex(&quot;I&quot;);<br>\r\n            graph.AddVertex(&quot;J&quot;);</p>\r\n<p>            // Create the streets (&lt;string&gt; -&gt; the edge is identified by a string value)<br>\r\n            Edge&lt;string&gt; a_e = new Edge&lt;string&gt;&quot;A&quot;, &quot;E&quot;);<br>\r\n            Edge&lt;string&gt; e_f = new Edge&lt;string&gt;(&quot;E&quot;, &quot;F&quot;);<br>\r\n            Edge&lt;string&gt; f_g = new Edge&lt;string&gt;(&quot;F&quot;, &quot;G&quot;);<br>\r\n            Edge&lt;string&gt; g_h = new Edge&lt;string&gt;(&quot;G&quot;, &quot;H&quot;);</p>\r\n<p>            // Add the streets<br>\r\n            graph.AddEdge(a_e);<br>\r\n            graph.AddEdge(e_f);<br>\r\n            graph.AddEdge(f_g);<br>\r\n            graph.AddEdge(g_h);</p>\r\n<p>            // Define some lengths to the streets<br>\r\n            Dictionary&lt;Edge&lt;string&gt;, double&gt; edgeCost = new Dictionary&lt;Edge&lt;string&gt;, double&gt;(graph.EdgeCount);<br>\r\n            edgeCost.Add(a_e, 1);<br>\r\n            edgeCost.Add(e_f, 1);<br>\r\n            edgeCost.Add(f_g, 1);<br>\r\n            edgeCost.Add(g_h, 1);<br>\r\n     <br>\r\n            DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt; dijkstra = new DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt;(graph, AlgorithmExtensions.GetIndexer&lt;Edge&lt;string&gt;, double&gt;(edgeCost));</p>\r\n<p>            // Attach a Vertex Predecessor Recorder Observer to give us the paths<br>\r\n            QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt; predecessorObserver = new QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();<br>\r\n            predecessorObserver.Attach(dijkstra);</p>\r\n<p>            // attach a distance observer to give us the shortest path distances<br>\r\n            VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt; distObserver = new VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt;(AlgorithmExtensions.GetIndexer&lt;Edge&lt;string&gt;, double&gt;(edgeCost));<br>\r\n            distObserver.Attach(dijkstra);</p>\r\n<p>            // Run the algorithm with A set to be the source<br>\r\n            dijkstra.Compute(&quot;A&quot;);</p>\r\n<p>            foreach (KeyValuePair&lt;string, Edge&lt;string&gt;&gt; kvp in predecessorObserver.VertexPredecessors)<br>\r\n                Console.WriteLine(&quot;If you want to get to {0} you have to enter through the in edge {1}&quot;, kvp.Key, kvp.Value);</p>\r\n<p>            foreach (KeyValuePair&lt;string, double&gt; kvp in distObserver.Distances)<br>\r\n                Console.WriteLine(&quot;Distance from root to node {0} is {1}&quot;, kvp.Key, kvp.Value);</p>\r\n<p>            // Remember to detach the observers<br>\r\n            predecessorObserver.Detach(dijkstra);<br>\r\n            distObserver.Detach(dijkstra);</p>\r\n",
    "PostedDate": "2009-03-02T00:26:37.77-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "163507",
    "ThreadId": "48719",
    "Html": "You can use the AlgorithmExtensions.ShortestPathsDijkstra method to do this kind of computation. It wraps the creation of a recorder/algorithm, etc...\r\n",
    "PostedDate": "2009-03-02T08:41:04.537-08:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  }
]