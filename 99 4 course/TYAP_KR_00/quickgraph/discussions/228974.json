[
  {
    "Id": "499841",
    "ThreadId": "228974",
    "Html": "<p>Hi,<br><br>First of all thanks a lot for that powerful and well-designed library !<br><br>The only problem is that I can't find any documentation about some parts of your work.<br>In particular, there is nothing about Xml Serialization when using custom fields.<br><br>The wiki documentation about this subject (http://quickgraph.codeplex.com/wikipage?title=Xml%20Serialization&amp;referringTitle=Documentation) indicates how it should work, but it's a bit hard to understand all the stuff as the example does not cover &quot;deserializing&quot; part and &quot;custom fields&quot; part.<br><br>I can't make the serialization/deserialization process work with custom fields.<br><br>Here is what I wrote (sorry for the indentation, the code snippet isn't supported by my Opera browser) :<br><br><span style=\"color:#808080\">using (var xwriter = XmlWriter.Create(outputFile1))</span><br><span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; QuickGraph.Serialization.SerializationExtensions.SerializeToXml&lt;MyVertex, MyEdge, AdjacencyGraph&lt;MyVertex, MyEdge&gt;&gt;(theGraph1,&nbsp;</span><br><span style=\"color:#808080\"> <span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span><span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span>xwriter, </span><br><span style=\"color:#808080\"> <span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span><span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span>v =&gt; v.ID.ToString(), </span><br><span style=\"color:#808080\"> <span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span><span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span>e =&gt; e.Id.ToString(), </span><br><span style=\"color:#808080\"> <span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span><span style=\"color:#808080\">&nbsp; &nbsp; &nbsp; </span>&quot;graph&quot;, &quot;v&quot;, &quot;e&quot;, &quot;&quot;);</span><br><br>where :<br>- theGraph1 is a AdjacencyGraph&lt;MyVertex, MyEdge&gt; graph<br>- MyVertex is a simple class with an unique int32 &quot;ID&quot; field<br>- MyEdge is a custom class with some simple custom fields (int32, string...) and a custom int32 &quot;ID&quot; field that I manage<br><br>This does not work. The graph is serialized, but custom fields are not saved (only source, target and ID for the edges).</p>\r\n<p>Here's what I get, for instance : &lt;e id=&quot;7456456&quot; source=&quot;1456146&quot; target=&quot;465496&quot; /&gt;</p>\r\n<p>I'm sure I should use</p>\r\n<p><span style=\"color:#888888\">public static void SerializeToXml&lt;TVertex, TEdge, TGraph&gt;(this TGraph graph, XmlWriter writer, VertexIdentity&lt;TVertex&gt; vertexIdentity, EdgeIdentity&lt;TVertex, TEdge&gt; edgeIdentity, string graphElementName, string vertexElementName, string edgeElementName, string namespaceUri, Action&lt;XmlWriter, TGraph&gt; writeGraphAttributes, Action&lt;XmlWriter, TVertex&gt; writeVertexAttributes, Action&lt;XmlWriter, TEdge&gt; writeEdgeAttributes)</span></p>\r\n<p>but what are the last parameters ???<br><br>Could you please provide an example ?<br><br>Oh, btw, I think there is a typo in your wiki example (&quot;MyVexte&quot;).<br><br>Thx !</p>",
    "PostedDate": "2010-09-29T02:43:14.847-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "499941",
    "ThreadId": "228974",
    "Html": "<p>Hi,</p>\r\n<p>I finally found the way to write my code, but there still is a problem with the deserialization process...</p>\r\n<p>Here's my code that deserializes :</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">using</span> (<span style=\"color:blue\">var</span> xreader = XmlReader.Create(xmlInputFile))\r\n\tres = QuickGraph.Serialization.SerializationExtensions.DeserializeFromXml&lt;MyVertex, MyEdge, AdjacencyGraph&lt;MyVertex, MyEdge&gt;&gt;(\r\n\t\txreader, \r\n\t\t<span style=\"color:#a31515\">&quot;graph&quot;</span>, <span style=\"color:#a31515\">&quot;vertex&quot;</span>, <span style=\"color:#a31515\">&quot;edge&quot;</span>, <span style=\"color:#a31515\">&quot;&quot;</span>,\r\n\t\txr =&gt; <span style=\"color:blue\">new</span> AdjacencyGraph&lt;MyVertex, MyEdge&gt;(),\r\n\t\txr =&gt; <span style=\"color:blue\">new</span> MyVertex(Int32.Parse(xr.GetAttribute(<span style=\"color:#a31515\">&quot;id&quot;</span>), CultureInfo.InvariantCulture)),\r\n\t\txr =&gt; <span style=\"color:blue\">new</span> MyEdge(xr.GetAttribute(<span style=\"color:#a31515\">&quot;id&quot;</span>), xr.GetAttribute(<span style=\"color:#a31515\">&quot;source&quot;</span>), xr.GetAttribute(<span style=\"color:#a31515\">&quot;target&quot;</span>), xr.GetAttribute(<span style=\"color:#a31515\">&quot;length&quot;</span>)));\r\n</pre>\r\n</div>\r\n<p>It throws a KeyNotFoundException... It's because the deserialization can't find target/source for my edges, because references between vertices are not the same. When an object is used as a key for a list, you can't use another instance of the key even if they ara equal. It's the same problem as here :</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> Test\r\n{\r\n\t<span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> go()\r\n\t{\r\n\t\tDictionary&lt;MyKeyObject, String&gt; dico = <span style=\"color:blue\">new</span> Dictionary&lt;MyKeyObject,<span style=\"color:blue\">string</span>&gt;();\r\n\t\tMyKeyObject key1 = <span style=\"color:blue\">new</span> MyKeyObject() { ID = 4 };\r\n\t\tMyKeyObject key2 = <span style=\"color:blue\">new</span> MyKeyObject() { ID = 4 };\r\n\r\n\t\tdico.Add(key1, <span style=\"color:#a31515\">&quot;test&quot;</span>);\r\n\t\tConsole.WriteLine(dico[key2]);  <span style=\"color:green\">// Not same references, so it throws KeyNotFoundException</span>\r\n\t}\r\n}\r\n</pre>\r\n</div>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>   <span style=\"color:blue\">class</span> MyKeyObject\r\n    {\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> ID;\r\n    }\r\n\r\n</pre>\r\n</div>\r\n<p><br>&nbsp;<br>key1 and key2 looks identical but the're not. References must be&nbsp;equal to use an object as a key.&nbsp;It's the same problem for the vertices.</p>\r\n<p><br>So I've looked at your XmlSerializationTest.cs file, and there's no problem as vertices are simple strings (no reference problem with strings). But how would you deal with a custom class as a vertex&nbsp;??</p>\r\n<p>Thanks,</p>",
    "PostedDate": "2010-09-29T05:49:00.57-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "500083",
    "ThreadId": "228974",
    "Html": "<p>Override the Equals and GetHashCode methods in your custom class. &nbsp;The default logic in the object class is to test for equality of reference. &nbsp;</p>\r\n<p>Since strings are memoized, all equal strings have the same reference.</p>",
    "PostedDate": "2010-09-29T09:13:43.347-07:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "500087",
    "ThreadId": "228974",
    "Html": "<p>I tried to override&nbsp;Equals and the result was the same... but I did not tried with GetHashCode. Thanks for the information, I'll try this !</p>",
    "PostedDate": "2010-09-29T09:28:23.507-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "500381",
    "ThreadId": "228974",
    "Html": "<p>&nbsp;</p>\r\n<p>Hi rhennig,<br><br>This worked perfectly, thanks a lot !<br><br>The only problem is now a performance issue.<br><br>I guess it's my HashCode function (which in fact simply returns the vertex ID to guarantee same return value for same vertices) that is not well distributed.<br>Or maybe Int32 values are always much faster than Objects as keys for collections ?</p>",
    "PostedDate": "2010-09-30T01:09:48.44-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "500660",
    "ThreadId": "228974",
    "Html": "<p>When debugging performance issues, measuring is always better than guessing what's wrong.&nbsp; Try running the VS profiler to see where the most time is being spent.</p>",
    "PostedDate": "2010-09-30T11:51:30.433-07:00",
    "UserRole": "Developer",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "500871",
    "ThreadId": "228974",
    "Html": "<p>Well actually it's not just a guess. Performance is way worse when using custom class than a simple Int32 as a key for a collection.<br>GetHashCode() and Equals() functions are called once per comparison, and it uses approximatively 30 times more CPU when used with a custom class than when used with an Int32.<br>Calls to GetHashCode() and Equals() then represent 25-30% of the whole process when using a ShortestPathsDijkstra algorithm for instance.<br>And this does even not take into account the probably bad distribution of my GetHashCode function (which is critical for key-related operations).<br><br>So yes, using a custom class with custom fields as a Vertex adds a large CPU overhead compared to Int32.<br><br></p>\r\n<p>Anyway, thanks again for your help !</p>",
    "PostedDate": "2010-10-01T01:20:49.823-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]