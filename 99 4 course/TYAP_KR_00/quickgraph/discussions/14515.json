[
  {
    "Id": "47195",
    "ThreadId": "14515",
    "Html": "\r\nI've been using PageRankAlgorithm and I found that creating FilteredBidirectionalGraph in PageRankAlgorithm throws<br />System.stackOverflowException<br /><br />if you remove in line 109 of PageRankAlgorithm.cs:<br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\nFilteredBidirectionalGraph&lt;\r\nVertex,\r\nEdge,\r\nIBidirectionalGraph&lt;Vertex,Edge&gt;\r\n&gt; fg = new FilteredBidirectionalGraph&lt;Vertex, Edge, IBidirectionalGraph&lt;Vertex, Edge&gt;&gt;(\r\nthis.VisitedGraph,\r\nnew InDictionaryVertexPredicate&lt;Vertex,double&gt;(this.ranks).Test,\r\nnew AnyEdgePredicate&lt;Vertex,Edge&gt;().Test\r\n);\r\n</pre><br />and add:<br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\nIBidirectionalGraph&lt;Vertex, Edge&gt; fg = this.VisitedGraph;\r\n</pre><br />there is no exception, but results seem to be wrong because GetRanksSum should return 1 according to this article of the american mathematical society: http://www.ams.org/featurecolumn/archive/pagerank.html<br /><br />I think it should be fixed with this new class that supports dangling nodes and converging fails related to non-primitive matrixes. (note that FilteredBidirectionalGraph is not used, so 'fg' variable has been replaced by this.VisitedGraph)<br /><br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n    [Serializable]\r\n    public sealed class PageRankAlgorithm&lt;Vertex, Edge&gt; :\r\n        AlgorithmBase&lt;IBidirectionalGraph&lt;Vertex, Edge&gt;&gt;\r\n        where Edge : IEdge&lt;Vertex&gt;\r\n    {\r\n        private IDictionary&lt;Vertex, double&gt; ranks = new Dictionary&lt;Vertex, double&gt;();\r\n \r\n        private int maxIterations = 60;\r\n        private double tolerance = 2 * double.Epsilon;\r\n        private double damping = 0.85;\r\n \r\n        public PageRankAlgorithm(IBidirectionalGraph&lt;Vertex, Edge&gt; visitedGraph)\r\n            : base(visitedGraph)\r\n        { }\r\n \r\n        public IDictionary&lt;Vertex, double&gt; Ranks\r\n        {\r\n            get\r\n            {\r\n                return this.ranks;\r\n            }\r\n        }\r\n \r\n        public double Damping\r\n        {\r\n            get\r\n            {\r\n                return this.damping;\r\n            }\r\n            set\r\n            {\r\n                this.damping = value;\r\n            }\r\n        }\r\n \r\n        public double Tolerance\r\n        {\r\n            get\r\n            {\r\n                return this.tolerance;\r\n            }\r\n            set\r\n            {\r\n                this.tolerance = value;\r\n            }\r\n        }\r\n \r\n        public int MaxIteration\r\n        {\r\n            get\r\n            {\r\n                return this.maxIterations;\r\n            }\r\n            set\r\n            {\r\n                this.maxIterations = value;\r\n            }\r\n        }\r\n \r\n        public void InitializeRanks()\r\n        {\r\n            this.ranks.Clear();\r\n            foreach (Vertex v in this.VisitedGraph.Vertices)\r\n            {\r\n                this.ranks.Add(v, 0);\r\n            }\r\n            //            this.RemoveDanglingLinks();\r\n        }\r\n                /*\r\n                public void RemoveDanglingLinks()\r\n                {\r\n                    VertexCollection danglings = new VertexCollection();\r\n                    do\r\n                    {\r\n                        danglings.Clear();\r\n \r\n                        // create filtered graph\r\n                        IVertexListGraph fg = new FilteredVertexListGraph(\r\n                            this.VisitedGraph,\r\n                            new InDictionaryVertexPredicate(this.ranks)\r\n                            );\r\n \r\n                        // iterate over of the vertices in the rank map\r\n                        foreach (IVertex v in this.ranks.Keys)\r\n                        {\r\n                            // if v does not have out-edge in the filtered graph, remove\r\n                            if (fg.OutDegree(v) == 0)\r\n                                danglings.Add(v);\r\n                        }\r\n \r\n                        // remove from ranks\r\n                        foreach (IVertex v in danglings)\r\n                            this.ranks.Remove(v);\r\n                        // iterate until no dangling was removed\r\n                    } while (danglings.Count != 0);\r\n                }\r\n        */\r\n \r\n        protected override void InternalCompute()\r\n        {\r\n            IDictionary&lt;Vertex, double&gt; tempRanks = new Dictionary&lt;Vertex, double&gt;();\r\n \r\n            int iter = 0;\r\n            double error = 0;\r\n            do\r\n            {\r\n                if (this.IsAborting)\r\n                    return;\r\n \r\n                // compute page ranks\r\n                error = 0;\r\n                foreach (KeyValuePair&lt;Vertex, double&gt; de in this.Ranks)\r\n                {\r\n                    if (this.IsAborting)\r\n                        return;\r\n \r\n                    Vertex v = de.Key;\r\n                    double rank = de.Value;\r\n                    // compute ARi\r\n                    double r = 0;\r\n                    foreach (Edge e in this.VisitedGraph.InEdges(v))\r\n                    {\r\n                        r += this.ranks[e.Source] / this.VisitedGraph.OutDegree(e.Source);\r\n                    }\r\n \r\n                    // DANGLING NODES\r\n                    // We assume a dangling node has a link to every other node in the graph\r\n                    // so it is not necessesary to remove dangling nodes\r\n                    foreach (Vertex currentVertex in this.VisitedGraph.Vertices)\r\n                    {\r\n                        if (this.VisitedGraph.IsOutEdgesEmpty(currentVertex))\r\n                        {\r\n                            r += tempRanks[currentVertex] / this.VisitedGraph.VertexCount;\r\n                        }\r\n                    }\r\n \r\n                    // add sourceRank and store\r\n                    // newRank represents the probability of going to the nodes linked to the\r\n                    // current node and to any other node in the graph\r\n                    // thus we fix those graphs that fails to converge\r\n                    double newRank = this.damping * r + (1 - this.damping) / this.VisitedGraph.VertexCount;\r\n                    tempRanks[v] = newRank;\r\n                    // compute deviation\r\n                    error += Math.Abs(rank - newRank);\r\n                }\r\n \r\n                // swap ranks\r\n                IDictionary&lt;Vertex, double&gt; temp = ranks;\r\n                ranks = tempRanks;\r\n                tempRanks = temp;\r\n \r\n                iter++;\r\n            } while (error &gt; this.tolerance &amp;&amp; iter &lt; this.maxIterations);\r\n            Console.WriteLine(\"{0}, {1}\", iter, error);\r\n        }\r\n \r\n        public double GetRanksSum()\r\n        {\r\n            double sum = 0;\r\n            foreach (double rank in this.ranks.Values)\r\n            {\r\n                sum += rank;\r\n            }\r\n            return sum;\r\n        }\r\n \r\n        public double GetRanksMean()\r\n        {\r\n            return GetRanksSum() / this.ranks.Count;\r\n        }\r\n \r\n    }\r\n</pre><br />I sent you an e-mail but I found this alternative way to post the problem. Sorry for the other mail.<br /><br />I hope this will help you to improve the library even more,<br /><br />regards<br />",
    "PostedDate": "2007-08-30T02:53:23-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]