[
  {
    "Id": "604467",
    "ThreadId": "255628",
    "Html": "\r\n<p>I noticed that when choosing the same node as start and end that Dijkstra always says &quot;no path,&quot; even if there is explicitly a self-edge in the graph. I found this by running random tests (code below).</p>\r\n<p>It seems sensible to say &quot;no path&quot; when there is no self-edge, but I'm surprised that it says &quot;no path&quot; when there is an explicit self-edge. Is this by design? Or a potential bug?</p>\r\n<p>The following LinqPad script will exhibit the phenomenon. Be sure to add a reference to the QuickGraph library (F4 in LinqPad), verify by looking at the dump that the self-edge 7-&gt;7 is in the graph, then notice that TryGetPath says &quot;False&quot;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">void</span> Main()\r\n{\r\n\t<span style=\"color:blue\">const</span> <span style=\"color:blue\">int</span> nNodes = 10;\r\n\t<span style=\"color:blue\">var</span> graphAsDict = RandomGraphWithSelfEdgeAsDict(nNodes).Dump(<span style=\"color:#a31515\">&quot;graphAsDict: Random graph as Dict&quot;</span>);\r\n\t\r\n\t<span style=\"color:blue\">var</span> velg1 = graphAsDict.ToVertexAndEdgeListGraph(\r\n\t\tkv =&gt; Array.ConvertAll&lt;<span style=\"color:blue\">int</span>, SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;&gt;(\r\n\t\t\tkv.Value.ToArray(),\r\n\t\t\tv =&gt; <span style=\"color:blue\">new</span> SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;(kv.Key, v))).Dump(<span style=\"color:#a31515\">&quot;velg1: Vertex and Edge-List Graph&quot;</span>);\r\n\r\n\tFunc&lt;SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;, <span style=\"color:blue\">double</span>&gt; edgeCost = (edge =&gt; 1.0D);\r\n\t\r\n<span style=\"color:green\">//\tint start = new Random(Guid.NewGuid().GetHashCode()).Next(1, nNodes &#43; 1).Dump(&quot;start point&quot;);</span>\r\n<span style=\"color:green\">//\tint end = new Random(Guid.NewGuid().GetHashCode()).Next(1, nNodes &#43; 1).Dump(&quot;end point&quot;);</span>\r\n\r\n\t<span style=\"color:blue\">int</span> start = 7.Dump(<span style=\"color:#a31515\">&quot;start point&quot;</span>);\r\n\t<span style=\"color:blue\">int</span> end = 7.Dump(<span style=\"color:#a31515\">&quot;end point&quot;</span>);\r\n\r\n\t<span style=\"color:blue\">var</span> algo = <span style=\"color:blue\">new</span> DijkstraShortestPathAlgorithm&lt;<span style=\"color:blue\">int</span>, SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;&gt;(velg1, edgeCost);\r\n\t<span style=\"color:blue\">var</span> predecessors = <span style=\"color:blue\">new</span> VertexPredecessorRecorderObserver&lt;<span style=\"color:blue\">int</span>, SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;&gt;();\r\n\t<span style=\"color:blue\">using</span> (predecessors.Attach(algo))\r\n\t{\r\n\t\talgo.Compute(start);\r\n\t\tIEnumerable&lt;SEquatableEdge&lt;<span style=\"color:blue\">int</span>&gt;&gt; path;\r\n\t\t<span style=\"color:blue\">if</span> (predecessors.TryGetPath(end, <span style=\"color:blue\">out</span> path).Dump(<span style=\"color:#a31515\">&quot;TryGetPath&quot;</span>))\r\n\t\t\tpath.Dump(<span style=\"color:#a31515\">&quot;path&quot;</span>);\r\n\t}\r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">int</span>[] RandomPermutation(Random ran, <span style=\"color:blue\">int</span> n)\r\n{\r\n\t<span style=\"color:blue\">var</span> r = Enumerable.Range(1, n).ToArray();\r\n\t<span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> i = 0; i &lt; n - 1; i&#43;&#43;)\r\n\t{\r\n\t\t<span style=\"color:blue\">var</span> k = ran.Next(i &#43; 1, n);\r\n\t\t<span style=\"color:blue\">var</span> t = r[i];\r\n\t\tr[i] = r[k];\r\n\t\tr[k] = t;\r\n\t}\r\n\t<span style=\"color:blue\">return</span> r;\r\n}\r\n\r\n<span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> Dictionary&lt;<span style=\"color:blue\">int</span>, IEnumerable&lt;<span style=\"color:blue\">int</span>&gt;&gt; \r\n\tRandomGraphWithSelfEdgeAsDict(<span style=\"color:blue\">int</span> nNodes)\r\n{\r\n\t<span style=\"color:blue\">var</span> ran = <span style=\"color:blue\">new</span> Random(Guid.NewGuid().GetHashCode());\r\n\t<span style=\"color:blue\">var</span> result = <span style=\"color:blue\">new</span> Dictionary&lt;<span style=\"color:blue\">int</span>, IEnumerable&lt;<span style=\"color:blue\">int</span>&gt;&gt;();\r\n\t\r\n\t<span style=\"color:blue\">for</span> (<span style=\"color:blue\">var</span> j = 1; j &lt;= nNodes; j&#43;&#43;)\r\n\t{\r\n\t\t<span style=\"color:blue\">var</span> k = ran.Next(0, nNodes);\r\n\t\t<span style=\"color:blue\">var</span> cs = RandomPermutation(ran, nNodes);\r\n\t\tresult[j] = cs.Take(k);\r\n\t}\r\n\t\r\n\t<span style=\"color:green\">// Now put in a self-edge on purpose, say 7 to 7</span>\r\n\t<span style=\"color:blue\">if</span> (!result[7].Contains(7))\r\n\t{\r\n\t\t<span style=\"color:blue\">var</span> _ = result[7].ToList();\r\n\t\t_.Add(7);\r\n\t\tresult[7] = _;\r\n\t}\r\n\t\r\n\t<span style=\"color:blue\">return</span> result;\r\n}\r\n</pre>\r\n</div>\r\n",
    "PostedDate": "2011-04-28T14:26:00.43-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "854776",
    "ThreadId": "255628",
    "Html": "<p>I noticed the same behavior in my bidirectional graph. I am not a graph expert to know whether this is expected behavior or not. I can of course assume the path to self always exists but it is not exactly what I need. Have you found any explanation/solution to this? BR, Tine</p>",
    "PostedDate": "2012-06-27T23:58:04.313-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]