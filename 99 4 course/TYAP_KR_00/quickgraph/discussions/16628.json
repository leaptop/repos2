[
  {
    "Id": "53877",
    "ThreadId": "16628",
    "Html": "\r\nThis post is in the name of Vitaliy:<br /><br />Hello Jonathan,<br /><br />I am working with the Quick graph package, and I encountered some implementation difficulties when trying to use it for an undirected graph. I consider myself to be a beginner software developer.<br /><br />In this letter I describe the problem and give two possible but incomplete design solutions to it. <br />Most of all I ask whether you happened to encounter the same problem and if so- how did you solve it.<br /><br />It seems that the package gives a very natural solution to directed graphs. <br />Indeed when we add an edge using AddEdge the line <br /><br />vertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=e.Source\">e.Source</a>.Add(e);<br /><br />makes sure that e.Target is adjacent to e.Source but not vice versa. <br /><br />But What happens when I wish to work with an undirected graph?<br /><br />The current method for adding an edge obviously does not suit, <br />When adding an edge from Vertex v to Vertex w, adjecence is not symmetric.<br /><br />I will describe two ideas that I had to solve that problem, but non of them seems to be complete. <br />I would appreciate your honest oppinion about them, <br />and which is more, your own idea of implementing an undirected graph.<br /><br />1. My first, and rather cumbersome solution, is to add the back edge of each inserted edge,<br />meaning the AddEdge method will look something like this:<br /><br />AddEdge(IVertex s, IVertex t)<br />{<br />\tIEdge e = EdgeProveider(s, t);<br />\t_vertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=s\">s</a>.Add(e);<br /><br />\tIf(_isDirectred)<br />\t{<br />\t\tIEdge reverse_e = EdgeProvider(t, s);<br /><i>vertexEdge<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=t\">t</a>.Add(reverse</i>e);<br />      }\t\t<br />}<br /><br />This way, I maintain the correctness of all traversal algorithms, <br />Since each vertex is reachable from every vertex it reaches.<br /><br />Alas, when the need arises to associate data with edges (such as weights) <br />and since additional data is concentrated in dictionaries- <br />I have to store each value twice:<br />Once under a forward edge and another time for its corresponding backward edge.<br />This causes initialization to be very ugly and empasizes that holding two edges to model a single, <br />undirected edge is bad practice.<br /><br />2. Naturally, my next solution is not to create a different back edge but to add the same edge twice: <br />once to the source and one more for the target. <br />The method AddEdge will look like this:<br /><br />AddEdge(IVertex s, IVertex t)<br />{<br />\tIEdge e = EdgeProveider(s, t);<br />\t_vertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=s\">s</a>.Add(e); \t// Add edge under s<br /><br />\tIf(!_isDirectred)<br />\t{<br />\t\t_vertexEdge<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=t\">t</a>.Add(e);\t//Add the same edge undet t<br />      }\t\t<br />}<br /><br />Thus, I have no “redundent” edges and each vertex knows what edges are incident to it.<br />But! And that is a serious “But!” In my first solution, when accessing vertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=v\">v</a>,<br />I knew for certain the the returned Edge Collection has edges directed from v:<br /><br />Foreach (IEdge e in vertexEdgesp<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=v\">v</a>)<br />{<br />\t// e.Target  always returns a vertex other then v.<br />}<br /><br />So if I replace it with the second solution, where I add the same edge twice, this may not be so. <br />In an iteration such as above (one which BFS heavily relies on) <br />may return an IEdge e that its Target equals the vertex whos edges we are enumerating: <br />e.Target will return v, giving incorrect results.<br /><br />This may be the case in the following example:<br /><br />Say I have an undirected instance of an Adjacency graph called _g.  <br />It has two vertices, whose corresponding objects are v1 and v2. <br /><br />_g.AddEdge(v1, v2) <br /><br />Causes an edge e to be inserted to _g.VertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=v1\">v1</a>, <br />such that e.source is v1 and e.Target is v2 and the same edge to be inserted to _g.VertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=v2\">v2</a> .<br /><br /><br />But then When I do: <br /><br />foreach (IEdge e in _g.VertexEdges<a href=\"http://www.codeplex.com/quickgraph/Wiki/View.aspx?title=v2\">v2</a>)<br />{<br />\t// I get an edge that e.Target equals v2.<br />}<br /><br />So I have no way of knowing whether e.Target is a neighbour of v2 (as I axpect) or v2 itself. <br /><br />How do you handle undirected graphs.<br /><br />Thank you in advance.<br />Vitaliy.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />",
    "PostedDate": "2007-10-18T06:28:17.537-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "54214",
    "ThreadId": "16628",
    "Html": "\r\nit'll take some time for an answer, i'm on vacation till nov <br />",
    "PostedDate": "2007-10-20T15:59:50.71-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  }
]