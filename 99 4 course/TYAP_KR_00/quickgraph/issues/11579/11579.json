{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "Added an EdgeEquality delegate in undirected graph that let you customize how edge/vertices are compared",
    "ClosedDate": "2009-04-10T07:53:42.65-07:00",
    "CommentCount": 0,
    "Custom": null,
    "Description": "Since the graph is Undirected, we by definition do not care about the ordering of vertices.\nSo, when adding an edge, sort the vertices, then add the edge.\n \nthis would allow the inner loop of ContainsEdge to be reduced to:\n \n    if (edge.Source.Equals(source) && edge.Target.Equals(target))\n        return true;\n \nThus saving Edges.Count compares per call.\n \nWe do have to do the initial compares while adding the edge, but we only load the graph\nonce, then work with it repeatedly.\n \nPerhaps an IVertex interface and then an IUndirectedVertex, which requires IEquatable and IComparable \nwould be needed.",
    "LastUpdatedDate": "2013-05-16T04:59:27.683-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "quickgraph",
    "ReportedDate": "2008-11-06T22:20:31.267-08:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Optimization for UndirectedGraph.ContainsEdge?",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 11579
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "The UndirectedGraph is the poor child of the library. It has not received much love. I will take a look.",
      "PostedDate": "2008-11-07T00:18:45.05-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Good idea. We don't need IVertex, the user can provide a Comparison<TVertex> if necessary.",
      "PostedDate": "2008-11-09T07:16:07.01-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Fix needed in these places:\r\nContainsEdge(IEnumerable<TEdge> edges, TEdge edge) \r\nContainsEdge(TVertex source, TVertex target)\r\n\r\n- dupe if statement",
      "PostedDate": "2008-11-09T18:41:12.053-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Because AddEdge(TEdge edge), it might happen that this edge has vertices not sorted. Because IEdge is immutable, I would have to store whether it's sorted. That means a little more overhead in space. Need to think about it.",
      "PostedDate": "2008-11-10T21:48:59.353-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Ah, I saw the ContractInvariant stuff..\r\n\r\nMaybe in IEdge, add a constructor with 2 params.\r\nWhen implemented in whatever descendant classes, sort the \r\nvertices as needed.\r\n\r\nAlso, what is NamedEdge useful for?!?\r\n\r\nThanks in advance.",
      "PostedDate": "2008-11-11T00:06:59.063-08:00",
      "Id": -2147483648
    },
    {
      "Message": "You cannot define constructor on interfaces. I would need a new IUndirectedEdge interface to fix this.\r\nNamedEdge is just a simple implementation of IEdge that has a string. Should be deprecated from TaggedEdge.",
      "PostedDate": "2008-11-11T08:08:52.957-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Immutable is a fuzzy concept. To create anything: 1) allocate memory 2) fill it with some useful values.\r\n\r\nSo what your immutable contract is supposed to enforce is more\r\nof a \"write once\" kind of thing.\r\n\r\nSeems like moving values around during the constructor should be fair game.\r\nAfter the immutable item is created, forbid updating properties..\r\n\r\nAnyway, the graph library seems to be working.\r\nNot sure if the perf improvement will matter to me as my largest graph\r\nwill be about 300k edges, with about 200k vertices.\r\nDjikstra in seconds is hoped for..\r\nMinutes, hours, days etc would be bad.",
      "PostedDate": "2008-11-11T19:45:19.613-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Immutability in this case is enforced through readonly fields, which are 'controlled' in the Edge ctor. The Undericted graph can change this.\r\nWe recently added a FibonacciHeap/Queue but I'm not sure that it is connected to the all the shortest path algorithms.",
      "PostedDate": "2008-11-11T23:17:28.097-08:00",
      "Id": -2147483648
    },
    {
      "Message": "I'm closing this by design. I may add a flag to the undirected graph to 'assume' sorted edges and bypass the double check.",
      "PostedDate": "2009-03-29T23:14:19.54-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-03-29T23:14:21.867-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2009-04-10T07:53:42.65-07:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T17:44:56.257-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-05-16T04:59:27.683-07:00",
      "Id": -2147483648
    }
  ]
}