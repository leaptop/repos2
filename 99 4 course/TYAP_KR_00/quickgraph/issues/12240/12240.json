{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": "2008-12-29T11:20:58.943-08:00",
    "CommentCount": 0,
    "Custom": null,
    "Description": "Hello,\nI tried to call PrimMinimumSpanningTreeAlgorithm for simple input and I got wrong results. So this is my input:\n AdjacencyGraph<TVertex,TEdge> adjency_graph with edges (1,2), (3,2),(3,4),(1,4) and all weights are equal to 1.\nI use the following code to call PrimMinimumSpanningTreeAlgorithm:\n \n     IDictionary<TEdge, double> weights = new Dictionary<TEdge, double>();\n     IEnumerable<TEdge> edges = adjency_graph.Edges;\n            foreach (TEdge edge in edges)\n            {\n                weights.Add(edge, 1);\n            }\n       UndirectedGraph<TVertex, TEdge> undirectedgraph =\n               new UndirectedGraph<TVertex, TEdge>();\n            foreach (TVertex v in adjency_graph.Vertices)\n                undirectedgraph.AddVertex(v);\n            foreach (TEdge e1 in adjency_graph.Edges)\n                if (!undirectedgraph.ContainsEdge(e1.Source, e1.Target))\n                    undirectedgraph.AddEdge(e1);\n \n   Then I call PrimMinimumSpanningTreeAlgorithm in debugging mode\n \n  Prim_alg =\n             new PrimMinimumSpanningTreeAlgorithm<TVertex, TEdge>(undirectedgraph, weights);\n \n           \n            Prim_alg.Compute(root);  //root is 1\n \n \n   I see in InternalCompute method that only (1,2) and (1,4) edges give TreeEdge event and it is not sufficient because vertex 3 does   not belong such tree.\n   I suppose that problem is because you process only edge.Target but not processedge.Source. I tried to improve\n  code of InternalCompute  as the following (in the cycle):\n  TVertex second_end;\n foreach (var edge in this.VisitedGraph.AdjacentEdges(u))\n                    {\n                        if (cancelManager.IsCancelling)\n                            return;\n                        double edgeWeight = this.EdgeWeights[edge];\n                        //My\n                        if(edge.Target.Equals(u))\n                        {\n                            second_end = edge.Source;\n                        }\n                        else\n                            second_end=edge.Target;\n                        if (\n                            queue.Contains(second_end) &&\n                            edgeWeight < this.minimumWeights[second_end]\n                            )\n                        {\n                            this.minimumWeights[second_end] = edgeWeight;\n                            this.queue.Update(second_end);\n                            this.OnTreeEdge(edge);\n                        }\n                    }\n \n Am I right or I have missed something?\n Thank you\nEvgeny",
    "LastUpdatedDate": "2013-05-16T04:59:24.737-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "High",
      "Severity": 150,
      "Id": 3
    },
    "ProjectName": "quickgraph",
    "ReportedDate": "2008-12-29T06:39:11.163-08:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Question about Prim spanning tree algorithm",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 12240
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Resolved with changeset 29426.",
      "PostedDate": "2008-12-29T11:20:58.943-08:00",
      "Id": -2147483648
    },
    {
      "Message": "I've totally rewritten Prim. I'm also comparing the results to Kruskal's algorithm to cross verify.",
      "PostedDate": "2008-12-29T11:21:49.713-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T17:44:53.09-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-05-16T04:59:24.737-07:00",
      "Id": -2147483648
    }
  ]
}