//изначально нужно иметь стартовый символ
            //распарсить терминалы на массивы чаров. Если среди чаров встречаются нетерминалы, 
            //заменять их терминалами, начиная слева
            //если длина слова укладывается в диапазон min max, то выводить в richtextbox это слово.
            //пока в строке есть нетерминалы, заменяем их терминалами, начиная слева
            //для достижения большей длины. 
            //Вывод называется левосторонним, если в нём на каждом шаге вывода  правило грамматики
            //применяется к самому левому нетерминальному символу в цепочке.
            //Вместо каждого нетерминала м.б. подставлено столько выражений, сколько определено в правилах
            //для этого нетерминала. Т.о., чтобы получить все комбинации, нужно подставить сначала первое выражение
            //вместо первого левого нетерминала. Потом второе выражение вместо первого левого нетерминала.
            //Так пока все не будут подставлены вместо первого левого нетерминала. Потом в каждом получившемся 
            //выражении нужно опять применить все правила к крайнему левому нетерминалу. В итоге иногда 
            //будут появляться выражения, не имеющие нетерминалов в своём составе, их нужно сохранить.
            //Однако я не рассмотрел ситуацию с нетерминалами, находящимися правее. Как только нетерминалы 
            //слева закончатся, нужно переходить правее и заменять нетерминалы справа. Т.о. кажется реальной задача
            //просто перебрать все варианты(до определённой длины) и из них взять все цепочки без нетерминалов.
            //Попробую построить алгоритм: создаю все комбинации до определённой длины, беру из них те, в
            //которых нет нетерминалов, печатаю. У меня есть число правил. Причём число правил м.б.
            //больше числа нетерминалов. Числа нетерминалов я не знаю.
            //Метод, видимо, должен быть рекурсивным, чтобы быть вызванным для всех случаев.
