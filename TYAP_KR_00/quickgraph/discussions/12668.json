[
  {
    "Id": "41345",
    "ThreadId": "12668",
    "Html": "\r\nI am just testing the quickgraph library and am trying to figure out how to:<br />a) Create a graph<br />b) Populate the graph<br />c) Visualize the graph<br />d) Run Dijkstra on the graph<br />e) Check the results from Dijkstra<br /><br />I was able to get through a-d(though still struggling a bit with c), but is really having a hard time figuring out how to get the results from the Dijkstra Algorithm. <br /><br />Can someone please post an example showing how to handle output from the Dijkstra algorithm. <br /><br />Do I need to hook up to some of the eventhandlers? If that is the way to do it, It am wondering how to interpret and store the results.<br /><br />Thanks<br />Allan<br />",
    "PostedDate": "2007-07-17T02:09:09.657-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "41380",
    "ThreadId": "12668",
    "Html": "\r\nYou need to attach 'observers' to the algorithm before execution (see VertexPredecessorRecorderObserver). There are different types of observers to build a parent vertex map, distance map, etc...<br /><br />The algorithm themselves don't do anything besides triggering events.<br />",
    "PostedDate": "2007-07-17T08:22:45.507-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "41482",
    "ThreadId": "12668",
    "Html": "\r\nI have created the graph from the example found in the Dijkstra  applet <br />http://www.dgp.toronto.edu/people/JamesStewart/270/9798s/Laffra/DijkstraApplet.html<br /><br />Heres is the code. Maybe someone will find it usefull when they start of with quickgraph --&gt;<br /><br />AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt; graph = new AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt;(true);<br /><br />            // Add some vertices to the graph<br />            graph.AddVertex(\"A\");<br />            graph.AddVertex(\"B\");<br />            graph.AddVertex(\"C\");<br />            graph.AddVertex(\"D\");<br />            graph.AddVertex(\"E\");<br />            graph.AddVertex(\"F\");<br />            graph.AddVertex(\"G\");<br />            graph.AddVertex(\"H\");<br />            graph.AddVertex(\"I\");<br />            graph.AddVertex(\"J\");<br /><br />            // Create the edges<br />            Edge&lt;string&gt; a_b = new Edge&lt;string&gt;(\"A\", \"B\");<br />            Edge&lt;string&gt; a_d = new Edge&lt;string&gt;(\"A\", \"D\");<br />            Edge&lt;string&gt; b_a = new Edge&lt;string&gt;(\"B\", \"A\");<br />            Edge&lt;string&gt; b_c = new Edge&lt;string&gt;(\"B\", \"C\");<br />            Edge&lt;string&gt; b_e = new Edge&lt;string&gt;(\"B\", \"E\");<br />            Edge&lt;string&gt; c_b = new Edge&lt;string&gt;(\"C\", \"B\");<br />            Edge&lt;string&gt; c_f = new Edge&lt;string&gt;(\"C\", \"F\");<br />            Edge&lt;string&gt; c_j = new Edge&lt;string&gt;(\"C\", \"J\");<br />            Edge&lt;string&gt; d_e = new Edge&lt;string&gt;(\"D\", \"E\");<br />            Edge&lt;string&gt; d_g = new Edge&lt;string&gt;(\"D\", \"G\");<br />            Edge&lt;string&gt; e_d = new Edge&lt;string&gt;(\"E\", \"D\");<br />            Edge&lt;string&gt; e_f = new Edge&lt;string&gt;(\"E\", \"F\");<br />            Edge&lt;string&gt; e_h = new Edge&lt;string&gt;(\"E\", \"H\");<br />            Edge&lt;string&gt; f_i = new Edge&lt;string&gt;(\"F\", \"I\");<br />            Edge&lt;string&gt; f_j = new Edge&lt;string&gt;(\"F\", \"J\");<br />            Edge&lt;string&gt; g_d = new Edge&lt;string&gt;(\"G\", \"D\");<br />            Edge&lt;string&gt; g_h = new Edge&lt;string&gt;(\"G\", \"H\");<br />            Edge&lt;string&gt; h_g = new Edge&lt;string&gt;(\"H\", \"G\");<br />            Edge&lt;string&gt; h_i = new Edge&lt;string&gt;(\"H\", \"I\");<br />            Edge&lt;string&gt; i_f = new Edge&lt;string&gt;(\"I\", \"F\");<br />            Edge&lt;string&gt; i_j = new Edge&lt;string&gt;(\"I\", \"J\");<br />            Edge&lt;string&gt; i_h = new Edge&lt;string&gt;(\"I\", \"H\");<br />            Edge&lt;string&gt; j_f = new Edge&lt;string&gt;(\"J\", \"F\");<br /><br />            // Add the edges<br />            graph.AddEdge(a_b);<br />            graph.AddEdge(a_d);<br />            graph.AddEdge(b_a);<br />            graph.AddEdge(b_c);<br />            graph.AddEdge(b_e);<br />            graph.AddEdge(c_b);<br />            graph.AddEdge(c_f);<br />            graph.AddEdge(c_j);<br />            graph.AddEdge(d_e);<br />            graph.AddEdge(d_g);<br />            graph.AddEdge(e_d);<br />            graph.AddEdge(e_f);<br />            graph.AddEdge(e_h);<br />            graph.AddEdge(f_i);<br />            graph.AddEdge(f_j);<br />            graph.AddEdge(g_d);<br />            graph.AddEdge(g_h);<br />            graph.AddEdge(h_g);<br />            graph.AddEdge(h_i);<br />            graph.AddEdge(i_f);<br />            graph.AddEdge(i_h);<br />            graph.AddEdge(i_j);<br />            graph.AddEdge(j_f);<br /><br />            // Define some weights to the edges<br />            Dictionary&lt;Edge&lt;string&gt;, double&gt; edgeCost = new Dictionary&lt;Edge&lt;string&gt;, double&gt;(graph.EdgeCount);<br />            edgeCost.Add(a_b, 4);<br />            edgeCost.Add(a_d, 1);<br />            edgeCost.Add(b_a, 74);<br />            edgeCost.Add(b_c, 2);<br />            edgeCost.Add(b_e, 12);<br />            edgeCost.Add(c_b, 12);<br />            edgeCost.Add(c_f, 74);<br />            edgeCost.Add(c_j, 12);<br />            edgeCost.Add(d_e, 32);<br />            edgeCost.Add(d_g, 22);<br />            edgeCost.Add(e_d, 66);<br />            edgeCost.Add(e_f, 76);<br />            edgeCost.Add(e_h, 33);<br />            edgeCost.Add(f_i, 11);<br />            edgeCost.Add(f_j, 21);<br />            edgeCost.Add(g_d, 12);<br />            edgeCost.Add(g_h, 10);<br />            edgeCost.Add(h_g, 2);<br />            edgeCost.Add(h_i, 72);<br />            edgeCost.Add(i_f, 31);<br />            edgeCost.Add(i_h, 18);<br />            edgeCost.Add(i_j, 7);<br />            edgeCost.Add(j_f, 8);<br /><br />            // We want to use Dijkstra on this graph<br />            DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt; dijkstra = new DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt;(graph, edgeCost);<br /><br />            // attach a distance observer to give us the shortest path distances<br />            VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt; distObserver = new VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();<br />            distObserver.Attach(dijkstra);<br /><br />            // Attach a Vertex Predecessor Recorder Observer to give us the paths<br />            VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt; predecessorObserver = new VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();<br />            predecessorObserver.Attach(dijkstra);<br /><br />            // Run the algorithm with A set to be the source<br />            dijkstra.Compute(\"A\");<br /><br />            foreach (KeyValuePair&lt;string, int&gt; kvp in distObserver.Distances)<br />                Console.WriteLine(\"Distance from root to node {0} is {1}\", kvp.Key, kvp.Value);<br /><br />            foreach(KeyValuePair&lt;string, Edge&lt;string&gt;&gt; kvp in predecessorObserver.VertexPredecessors)<br />                Console.WriteLine(\"If you want to get to {0} you have to enter through the in edge {1}\", kvp.Key, kvp.Value );<br /><br />            // Remember to detach the observers<br />            distObserver.Detach(dijkstra);<br />            predecessorObserver.Detach(dijkstra);<br />",
    "PostedDate": "2007-07-17T17:03:40.69-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "41484",
    "ThreadId": "12668",
    "Html": "\r\nAnd based on the above code I have a few more questions.<br /><br />a) <br />I find it a bit tedious to have to save all the edge instances and assign them names(ie. a_b) in order to construct the weights Dictionary that requires an edge reference as key. <br /><br />I only found an enumerator for the edges in the Adjecency graph, but no indexer. Hence there is no obvious way to access the edges without having a reference to it in the code. Did I miss something or can the weights be constructed in a less tedious way?<br /><br />b)<br />Could you please explain the output from the code above?<br />Distance from root to node A is 0<br />Distance from root to node B is 0<br />Distance from root to node D is 0<br />Distance from root to node C is 0<br />Distance from root to node E is 0<br />Distance from root to node G is 0<br />Distance from root to node F is 1<br />Distance from root to node J is 0<br />Distance from root to node H is 1<br />Distance from root to node I is 0<br />If you want to get to B you have to enter through the in edge A-&gt;B<br />If you want to get to D you have to enter through the in edge A-&gt;D<br />If you want to get to C you have to enter through the in edge B-&gt;C<br />If you want to get to E you have to enter through the in edge B-&gt;E<br />If you want to get to G you have to enter through the in edge D-&gt;G<br />If you want to get to F you have to enter through the in edge J-&gt;F<br />If you want to get to J you have to enter through the in edge C-&gt;J<br />If you want to get to H you have to enter through the in edge G-&gt;H<br />If you want to get to I you have to enter through the in edge F-&gt;I<br /><br />The vertex predecessors seems to aggree with the applet solution, but how do you interpret the distances? They are merely 0 and 1.<br /><br />Sorry for the long posts and please have patience with me.<br />Allan<br />",
    "PostedDate": "2007-07-17T17:18:46.833-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "41592",
    "ThreadId": "12668",
    "Html": "\r\na) refactor your code and write a method that adds the vertices if needed, create the edge and set the weight.<br />b) i need to take a second look<br />",
    "PostedDate": "2007-07-18T08:59:40.13-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42101",
    "ThreadId": "12668",
    "Html": "\r\nAfter deleting a few of the solutions in the library I was able to compile the QuickGraph library. I wasn't able to find the GLEE reference files anywhere on the Internet, though?<br /><br />Hoping to understand the 0 and 1's in my solution above I started debugging with Visual Studio. This turned out to be quite a task and I still haven't found usefull information.<br /><br />Any help would be greatly appreciated. <br />",
    "PostedDate": "2007-07-23T02:16:17.437-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42150",
    "ThreadId": "12668",
    "Html": "\r\nThe GLEE link is in the wiki.<br />",
    "PostedDate": "2007-07-23T09:36:34.643-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42188",
    "ThreadId": "12668",
    "Html": "\r\nThanks a lot Pelikhan. <br /><br />I found the GLEE link. I will try to compile the entire package when I learn more about the Dijkstra output. This is my main concern right now.<br /><br />We are considering Quickgraph as the base for a prototype simulation in a project at the Technical University of Denmark. But obviously we also need to consider algorithmic correctness and performance.<br /><br />Based upon your experience with boost and quickgraph, may I ask, if we should expect a significant decrease in performance compared to using the Boost C++ implementation. We will be deploying very large sparse graphs and will primarily need the Dijkstra Algorithm to run on these large graphs. <br /><br />Allan<br />",
    "PostedDate": "2007-07-23T12:27:23.94-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42215",
    "ThreadId": "12668",
    "Html": "\r\nYou should expect decrease in performance, to what extend I am not sure. I don't know of anybody who actually used it for huge graphs.<br /><br />- Boost is highly optimized/templated code, QuickGraph is managed (good sides, bad sides)<br />- Boost has a record of handling big graphs, QuickGraph has not,<br />- it has better a priority queue implementation (fibonaci queue) which should give better result out of Dijsktra - QuickGraph impl. is fairly naive, you will have to write your own.<br />",
    "PostedDate": "2007-07-23T15:09:55.777-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42947",
    "ThreadId": "12668",
    "Html": "\r\nLearning that Quickgraph is not ported with the same optimizations as Boost \"scared\" us away for now. But keep up the good work Pelikhan. We hope that QuickGraph will one day offer state-of-the-art algorihms and implementations. For now it has been a good source of inspiration.<br /><br />We have implemented our own graph environment and Dijkstra algorithm with a Priority Queue. <br /><br />Allan<br />",
    "PostedDate": "2007-07-30T03:10:31.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "42991",
    "ThreadId": "12668",
    "Html": "\r\nNote that we've never tried to run benchmark to determine how 'bad' it is... QuickGraph let's you do graph in the managed environment: faster prototyping, garbage collection, better tools. Of course, there's no free lunch :) <br />",
    "PostedDate": "2007-07-30T08:36:12.707-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "43021",
    "ThreadId": "12668",
    "Html": "\r\nWorking with QuickGraph in the managed C# environment feels like a steak dinner lunch compared to template programming with boost :-)<br /><br />We have found sources, that used C# and they report that the \"penalty\" for using a managed environment is not significant as long as you are working with static graphs. Static meaning that you are not making changes to your graph once it is build and being cautious when allocating memory for your algorithms. If you can keep the activity of the garbage collector close to zero, the runtime of algorithmic operations is comparable to C++.<br /><br />But it would certainly be an interesting study if someone would implement similar large graphs in both boost and QuickGraph an use these to compare the enviromental penalty.<br /><br />",
    "PostedDate": "2007-07-30T10:22:51.88-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "54186",
    "ThreadId": "12668",
    "Html": "\r\nI'm trying to use the distance observer.<br />I was expecting to get the distance from source to vextex a in the dictionnary, but it is not.<br />I've just look at the code of quickgraph and understand that distance value is an int.<br />Like Sandrasmurf I don't understand the concept of distance map.<br /><br />Could you help<br />",
    "PostedDate": "2007-10-20T06:03:46.23-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "54221",
    "ThreadId": "12668",
    "Html": "\r\nthere might be a bug there, looking<br />",
    "PostedDate": "2007-10-20T18:43:44.85-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "54223",
    "ThreadId": "12668",
    "Html": "\r\nThe distance observer has nothing to do with dijkstra. Just use the recorder observer to build the tree, then walk the list of predessor edge and compute the distance on the fly:<br /><br />(i've also updated the ObserverScope to make it easier to attach/detach):<br /><pre style=\"background-color:#ECECEC; border:dashed .1em #3E62A6; font-family:Consolas, Courier New, Courier, Monospace; font-size:1em; margin-top:0; padding:.5em; height:auto; overflow:auto; overflow-x:auto; overflow-y:auto;\">\r\n            // We want to use Dijkstra on this graph\r\n            DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt; dijkstra = new DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt;(graph, edgeCost);\r\n \r\n            // Attach a Vertex Predecessor Recorder Observer to give us the paths\r\n            VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt; predecessorObserver = new VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();\r\n            using (ObserverScope.Create&lt;IVertexPredecessorRecorderAlgorithm&lt;string, Edge&lt;string&gt;&gt;&gt;(dijkstra, predecessorObserver)) {\r\n                // Run the algorithm with A set to be the source\r\n                dijkstra.Compute(\"A\");\r\n            }\r\n \r\n            foreach (KeyValuePair&lt;string, Edge&lt;string&gt;&gt; kvp in predecessorObserver.VertexPredecessors)\r\n                Console.WriteLine(\"If you want to get to {0} you have to enter through the in edge {1}\", kvp.Key, kvp.Value);\r\n \r\n            foreach (string v in graph.Vertices) {\r\n                double distance = 0;\r\n                string vertex = v;\r\n                Edge&lt;string&gt; predecessor;\r\n                while (predecessorObserver.VertexPredecessors.TryGetValue(vertex, out predecessor)) {\r\n                    distance += edgeCost[predecessor];\r\n                    vertex = predecessor.Source;\r\n                }\r\n                Console.WriteLine(\"A -&gt; {0}: {1}\", v, distance);\r\n            }\r\n \r\n</pre>",
    "PostedDate": "2007-10-20T19:16:05.223-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "54230",
    "ThreadId": "12668",
    "Html": "\r\nThanks a lot for your answer.<br /><br />I'm using quickgraph to find shortest path from A to B on the french railway network.<br />For the moment, it's just a test that works great.<br />I have now to model all the constraints in the grah, so still some works to do<br />I hope I will find the time.<br />For the moment the graph is 2200 vertices 6400 edges and it works well on a small laptop<br />",
    "PostedDate": "2007-10-21T01:00:24.35-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "62871",
    "ThreadId": "12668",
    "Html": "\r\nAs long as you don't have millions of vertices :)<br />",
    "PostedDate": "2007-12-13T10:38:36.227-08:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "101503",
    "ThreadId": "12668",
    "Html": "<p>Really It was agreat discussion as iam new with quick graph and also want to run the dijkstra algorithm With SharpMap,<br>\r\nBut I have some Questions:</p>\r\n<p>1)AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt; graph = new AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt;(true);<br>\r\n&nbsp;&nbsp; 1.1)what's true value mean??<br>\r\n&nbsp;&nbsp; 1.2) are this wil be available if we exchange &quot;string&quot; with&nbsp;sharpMap.Geometry of type Point ??????<br>\r\n<br>\r\n2)what's Mean By&nbsp;'observers' ??? and can u just give me alittle explain about it's types i will use to run the dijkstraaa like:&quot;VertexPredecessorRecorderObserver&quot;and it's importance???<br>\r\n<br>\r\n3)your cade seeked to compute all pathes from Node &quot;A&quot;,<br>\r\n&nbsp;&nbsp; Well,What about i want to get the shortest path from Node &quot;A&quot; To Node &quot;D&quot; ForExample.<br>\r\n<br>\r\n4) why we do that:<br>\r\n// Remember to detach the observers<br>\r\ndistObserver.Detach(dijkstra);<br>\r\npredecessorObserver.Detach(dijkstra);<br>\r\n<br>\r\n<br>\r\nthanxx in advance,<br>\r\nElSendrella</p>\r\n",
    "PostedDate": "2008-06-29T13:55:04.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "102828",
    "ThreadId": "12668",
    "Html": "Hi<br>\r\n<br>\r\nFirst, I would like to thank you for creating QuickGraph<br>\r\n<br>\r\nI have some problems with dijekstra<br>\r\n<br>\r\nis it suppose to work?<br>\r\n<br>\r\nI have observed the source code and found that its usind the dfs algorithm events.<br>\r\nin dijekstra you suppose to choose an edge that gives the minimal weight path from the discovered group to some vertex that wasnt discovered yet:<br>\r\n<br>\r\nin each step <br>\r\n&nbsp;&nbsp;&nbsp; examine the edges that goes out from the discovered vertices to the other<br>\r\n&nbsp;&nbsp;&nbsp; select the closest undiscovered vertex v such that w(s,v) is minaimal <br>\r\n&nbsp;&nbsp;&nbsp; add v to the discovered vertices<br>\r\n<br>\r\n&nbsp;<br>\r\nbut what happens in the code is different.<br>\r\nits a simple dfs that doesnt choose the &quot;right&quot; vertex in each step<br>\r\n<br>\r\nThe key to success is to make it choose the right edge in each step, any idea how to make the dfs do that?<br>\r\n<br>\r\n<br>\r\nI can offer the following implelmentation which does the job but is not robust or &quot;wanabe&quot; efficiant..<br>\r\n<br>\r\nclass dijekstra<br>\r\n&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Dictionary&lt;TVertex, double&gt; Distances;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Dictionary&lt;TVertex, TEdge&gt; ssTreePredecssors;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void runDijekstra(IVertexAndEdgeListGraph&lt;TVertex, TEdge&gt; g, &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IDictionary&lt;TEdge, double&gt; weights, TVertex source)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssTreePredecssors = new Dictionary&lt;TVertex, TEdge&gt;();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distances = new Dictionary&lt;TVertex, double&gt;();<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;TVertex&gt; Undiscovered = new List&lt;string&gt;();<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initialize<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (TVertex v in g.Vertices)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distances.Add(v, double.MaxValue);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Undiscovered.Add(v);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Undiscovered.Remove(source);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distances.Remove(source);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distances.Add(source, 0);<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (Undiscovered.Count &gt; 0)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TEdge bestEdge =null;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (TEdge e in weights.Keys)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!Undiscovered.Contains(e.Source)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; Undiscovered.Contains(e.Target))<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bestEdge == null) { bestEdge = e; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Distances[bestEdge.Source] + weights[bestEdge] &gt; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Distances[e.Source] + weights[e])<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bestEdge = e;<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no need to check edges between discovered vertices<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!Undiscovered.Contains(e.Source)<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !Undiscovered.Contains(e.Target))<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //weights.Remove(e);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bestEdge == null) { return; };<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Distances[bestEdge.Target] = Distances[bestEdge.Source]+&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; weights[bestEdge];<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weights.Remove(bestEdge);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Undiscovered.Remove(bestEdge.Target);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssTreePredecssors.Add(bestEdge.Target, bestEdge);<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp; }<br>\r\n<br>\r\nit gave the correct result for the code in a previus post:<br>\r\n(the example in : http://www.dgp.toronto.edu/people/JamesStewart/270/9798s/Laffra/DijkstraApplet.html)<br>\r\nDistance from root to node {A} is {0}<br>\r\nDistance from root to node {B} is {4}<br>\r\nDistance from root to node {C} is{6}<br>\r\nDistance from root to node {D} is {1}<br>\r\nDistance from root to node {E} is {16}<br>\r\nDistance from root to node {F} is {26}<br>\r\nDistance from root to node {G} is {23}<br>\r\nDistance from root to node {H} is {33}<br>\r\nDistance from root to node {I} is {37}<br>\r\nDistance from root to node {J} is {18}<br>\r\n<br>\r\nDistance from root to node {D} is {A-&gt;D}<br>\r\nDistance from root to node {B} is {A-&gt;B}<br>\r\nDistance from root to node {C} is {B-&gt;C}<br>\r\nDistance from root to node {E} is {B-&gt;E}<br>\r\nDistance from root to node {J} is {C-&gt;J}<br>\r\nDistance from root to node {G} is {D-&gt;G}<br>\r\nDistance from root to node {F} is {J-&gt;F}<br>\r\nDistance from root to node {H} is {G-&gt;H}<br>\r\nDistance from root to node {I} is {F-&gt;I}<br>\r\n",
    "PostedDate": "2008-07-05T05:28:59.133-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "113513",
    "ThreadId": "12668",
    "Html": "There was a bug in the dijkstra algorithm, I was hooking to the wrong event in the BFS (TreeEdge instead of ExamineEdge), which might have produced invalid path.<br>\r\n<br>\r\nFixed in the source now.\r\n",
    "PostedDate": "2008-08-25T10:20:47.57-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1045115",
    "ThreadId": "12668",
    "Html": "Hello, I don't know if this project is still being worked on or if these forums are still being monitored but I was wondering if anyone could assist me. I wanted to try out the example that sandrasmurf had originally posted so I could try to leanr about how to use QuickGraph in other ways, since I'm still fairly new to the QuickGraph library, but I'm getting compile errors. \r<br />\n<br />\nOne error I am getting is when she is instantiating a new DijkstraShortestPathAlgorithm variable called dijkstra. On the second half of the instantiation, I get the error &quot;The best overloaded method match for 'QuickGraph.Algorithms.ShortestPath.DijkstraShortestPathAlgorithm&lt;string,QuickGraph.Edge&lt;string&gt;&gt;.DijkstraShortestPathAlgorithm(QuickGraph.IVertexListGraph&lt;string,QuickGraph.Edge&lt;string&gt;&gt;, System.Func&lt;QuickGraph.Edge&lt;string&gt;,double&gt;)' has some invalid arguments &quot;\r<br />\n<br />\nThe other errors occur when she attemps to create the VertexDistanceRecorderObserver. I am thinking I might be able to substitute some of that code with the code that pelikhan is using. For right now I would just like to know the correct syntax for creating the DijkstraShortestPathAlgorithm.\r<br />\n<br />\nThanks in advance and thanks alot for creating the QuickGraph library. If I can get it to work I think it could save me alot of having to learn C++/CLI code.<br />\n",
    "PostedDate": "2013-05-17T07:33:10.47-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]