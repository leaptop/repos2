[
  {
    "Id": "194086",
    "ThreadId": "57427",
    "Html": "<p>Hi,</p>\r\n<p>I need to work with huge graphs (10 million nodes, 200 million edges) with edges Edge&lt;int, int&gt;. Is there a&nbsp;way to&nbsp;allocate and initialize the edges with one memory allocation&nbsp;in an array, preferably as value type,&nbsp;as opposite to creating 200 million tiny objects?&nbsp;How much memory should I&nbsp;expect such a graph to take per vertex/edge?</p>\r\n<p>Thanks,</p>\r\n<p>Vlad&nbsp;</p>",
    "PostedDate": "2009-05-25T21:07:05.983-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "194091",
    "ThreadId": "57427",
    "Html": "<p>Yes, use SEdge&lt;int,int&gt; instead which is a value type. Let's see: 8-byte * 200 * 10^6 = 1600Mb &nbsp;and that's a lower bound. If you have a 64bit machine it should not be an issue, otherwize QuickGraph might not be the best tool to deal with large graphs. The PBGL (<a href=\"http://www.osl.iu.edu/research/pbgl/\">http://www.osl.iu.edu/research/pbgl/</a>) is probably a more scalable solution.</p>",
    "PostedDate": "2009-05-25T21:49:09.6-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195019",
    "ThreadId": "57427",
    "Html": "<p>Thanks for your suggestion. &nbsp;I'm trying to replace edges with SEdges, as now without it I'm running out of memory building a graph of 10M edges. (I have a 64bit, 4G Ram machine). But unless QuickGraph has some significant overhead over Boost, i.e. much more than 8 bytes per int-int edge, plus 4 bytes per cost, I would be fine.</p>\r\n<p>&nbsp;</p>\r\n<p>Just one more question.&nbsp;How would you initialize a static undirected clique on integers, say range [1..10000], with score equal to 1 for every edge (I would like to run a spanning tree algorithm on it)?</p>\r\n<p>Would you use AddVerticesAndEdge range? And how would store costs efficiently? If I understand correctly, just using Dictionary will create a linked list of all values for given hash key, i.e. every int will be stored as an object.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks,</p>\r\n<p>&nbsp;Vlad</p>",
    "PostedDate": "2009-05-27T19:19:54.217-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195021",
    "ThreadId": "57427",
    "Html": "<p>A clarification: I can either write a function</p>\r\n<p>int Cost(SEdge e)</p>\r\n<p>or write my own bijective hash function Edges-&gt;[0..num_edges-1] and store the Costs in the array or List.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks,</p>\r\n<p>Vlad</p>",
    "PostedDate": "2009-05-27T19:25:27.02-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195049",
    "ThreadId": "57427",
    "Html": "<p>do you plan to mutate the costs? If not, you could simple use a delegate that returns 1 and be done. If some of the costs would have to be mutated, you could have a small dictionary containing the mutated costs - in that sense you would pay a lesser cost on memory.</p>\r\n<p>You could also implement your own struct that implements IEdge and has a cost field. You probably want to add the vertices (AddVertexRange), then the edges (AddEdgeRange) - it should be slightly more efficient.</p>",
    "PostedDate": "2009-05-27T22:52:42.453-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195061",
    "ThreadId": "57427",
    "Html": "<p>Thanks for you quick response. No, I will not mutate neither costs nor the graph - everything is static. Costs of 1 in a clique were just an example, I now build an array of costs, but will use&nbsp;<span style=\"font-family:'Courier New';color:#30332d\">STaggedEdge&lt;TVertex, TTag&gt; edge. I assume using tag for edge costs is OK.</span></p>\r\n<p>&nbsp;</p>\r\n<p>I just don't quite understand what <span style=\"color:#30332d\">AddEdgeRange does internally. If I pass it List&lt;SEdge&gt;, since the function expects IEnumerable, it would not reuse the array and instead would allocate memory for Edges individually (and copy them to a List&lt;Edge&gt; anyway ?), 200 million times in my case, am I right?</span></p>\r\n<p>&nbsp;</p>\r\n<p><span style=\"color:#30332d\">Thanks,</span></p>\r\n<p><span style=\"color:#30332d\">Vlad</span></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-05-28T00:30:40.213-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195168",
    "ThreadId": "57427",
    "Html": "<p>In your case where the graph is immutable, we probably need a new/better data structure to represent it.</p>",
    "PostedDate": "2009-05-28T05:45:11.99-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195272",
    "ThreadId": "57427",
    "Html": "<p>I've added ArrayAdjacencyGraph which uses a more consice representation. There's a bug in the contracts rewritter so I have not tested it thorousgly yet.</p>",
    "PostedDate": "2009-05-28T08:59:51.337-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195512",
    "ThreadId": "57427",
    "Html": "<p>Thanks, that was fast!</p>\r\n<p>I'm reading through the code now, it looks it does not support undirected graph yet. Sorry, if I was not particularly clear, I'm running a spanning tree algorithms on an undirected graph.</p>\r\n<p>Thanks,</p>\r\n<p>Vlad</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-05-28T17:54:40.127-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "195991",
    "ThreadId": "57427",
    "Html": "<p>Hi,<br><br>I have an idea how to overcome the scalability problem and I'm interested if it's feasible or, maybe, even already present in QuickGraph.<br><br>Is it possible to provide instead of edges enumerators or delegates that given a vertex produce the set of its neighbors? For example, in my particular case vertices are short strings and edges connect similar strings, with weigh equal to the degree of similarity. Instead of storing a huge set of outgoing or incoming edges anywhere to be used just once, I could compute them on as-needed basis. This recomputing will work for near O(n) algorithms, like spanning tree or strongly connected components and not so good for, say, flow. But the good thing is that the graph interface is decoupled from the data structure, and if the recomputation is expensive, the user can store the data in array or what ever is efficient for her and just compute the delegates with ability to reuse all the algorithms implemented in QuickGraph.<br><br><br>One problem that I see here is that pre-computing and storing O(V) delegates is not particularly space efficient, higher order functions would be required, AFAIK, here - QuickGraph can receive a function that given a vertex index computes a function that enumerate the neighbors/edges.&nbsp; I'm using QuickGraph with F#, and this is easily done there, not familiar with C# yet.<br><br><br>Is this something feasible, already available or I'm missing something major? <br><br><br>Thanks,<br><br>Vlad</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-05-30T09:44:15.523-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196029",
    "ThreadId": "57427",
    "Html": "<p>Take a look at the FunctionalImplicitGraph to see if this is something that could fit your needs. It relies solely on a delegate of the form:</p>\r\n<p>&nbsp;&nbsp; &nbsp; bool TryFunc&lt;TVertex, IEnumerable&lt;TEdge&gt;&gt;(TVertex v, out IEnumerable&lt;TEdge&gt; edges);</p>\r\n<p>so you can lazily get the out edges and enumerate them.</p>",
    "PostedDate": "2009-05-30T14:26:31.723-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196031",
    "ThreadId": "57427",
    "Html": "<p>I've renamed it to DelegateImplicitUndirectedGraph. Let's what you can do with this one.</p>",
    "PostedDate": "2009-05-30T14:42:17.65-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196070",
    "ThreadId": "57427",
    "Html": "<p>Thanks,<br><br>It looks this will work for me. Do you have any idea how much memory will it take internally if I run a spanning tree algorithm? I guess <span id=10.sc>Kruskal</span> will not be efficient as it has to put in advance all edges into the heap or sort them by cost, so <span id=11.sc>laziness</span> in graph representation will not help much. But <span id=12.sc>Prim's</span> heap contains only the edges between the &quot;<span id=13.sc>supernode</span>&quot; and its complement, so theoretically, we are talking about $O(V)$ worst case memory used internally. Is it how it works?<br><br><br>One <span id=14.sc>newbie</span> question - I could not find build instructions anywhere. How do I create QuickGraph.dll from the source? I opened sources/<span id=15.sc>QuickGraph</span>.<span id=16.sc>sln</span> in Visual Studio 2010 Beta 1, it offered to convert something; then, when I tried to build the project I got a bunch of errors.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-05-30T18:45:28.07-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196091",
    "ThreadId": "57427",
    "Html": "<p>Yeah with respect to the build, just unload whatever project that does not build. Msal/Glee require different components that are not checked in the depot. QuickGraph is the root project and should build.</p>",
    "PostedDate": "2009-05-30T22:07:59.203-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196092",
    "ThreadId": "57427",
    "Html": "<p>QuickGraph contains Kruskal's algorithm only. I did not migrate Prim's implementation from QuickGraph 1.0.</p>",
    "PostedDate": "2009-05-30T22:39:45.413-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196170",
    "ThreadId": "57427",
    "Html": "<p>I just noticed that even superlinear algorithms may have no time overhead due to lazy edge computation in implicit graphs. For example, while Prim is superlinear, each edge is iterated only once, so disregarding the differences in cache performance, the time will be exactly the same as if all E edges are precomputed.</p>",
    "PostedDate": "2009-05-31T12:09:23.997-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "196210",
    "ThreadId": "57427",
    "Html": "<p>I correct a previous comment: Prim is supported see&nbsp;<a href=\"http://quickgraph.codeplex.com/Wiki/View.aspx?title=Minimum Spanning Tree&referringTitle=Home\">http://quickgraph.codeplex.com/Wiki/View.aspx?title=Minimum%20Spanning%20Tree&amp;referringTitle=Home</a>.</p>\r\n<p>Curious to see, how far you can go with the lazy graphs.</p>",
    "PostedDate": "2009-05-31T16:34:49.323-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "212874",
    "ThreadId": "57427",
    "Html": "<p>Something wrong goes on with the Delegate graphs. Below I attach an example of a very simple graph where I try to find a spanning tree. Sorry for F# code, in C# I cannot write, only read.</p>\r\n<p>getMEM_filter_simple uses chains_scores_1_read_simple to generate a graph of 99 nodes, with edge i&lt;- &gt;i+1 of weight 0 for all i in [0..97] and 4 edges of non-zero weight. This graph has a maximum spanning tree of weight 40.</p>\r\n<p>When I use Kruskal (the weights are set as &quot;minus tag&quot;) I get the correct result of 40. If MinimumSpanningTreeKruskal is replaced with MinimumSpanningTreePrim I get a result of 32 with edge 68-93 missing from the optimal tree. I tried to replace FibonacciHeap</p>\r\n<p>with the BinaryQueue and got&nbsp; another result for MST: 24! (Side note, I head to modify in &quot;class BinaryQueue&lt;TVertex, TDistance&gt; : &nbsp;&nbsp;&nbsp; IQueue&lt;TVertex&gt;&quot; IQueue to IPriorityQueue. For some reason it was different than in FibonacciQueue).</p>\r\n<p>&nbsp;</p>\r\n<p>I did not have such a discrepancy between Kruskal and Prim prior to switching to the Delegate graph. Notice that Kruskal has to precompute all the edges in advance so for Kruskal the Delegates does not matter.</p>\r\n<p>---------------------------------------------------------------------------</p>\r\n<p>&nbsp;</p>\r\n<p>(*bug.fs*)</p>\r\n<p>#light<br>open System<br>open QuickGraph<br>open QuickGraph.Algorithms<br>open QuickGraph.Collections<br>open System.Collections.Generic<br>open System.IO<br><br>let chains_scores_1_read_simple input_read =&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; let edge =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match input_read with<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |19 -&gt; seq[new SUndirectedTaggedEdge&lt;int, int&gt; (19, 47, 11);new SUndirectedTaggedEdge&lt;int, int&gt; (input_read, input_read+1, 0)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |61 -&gt;&nbsp; seq[new SUndirectedTaggedEdge&lt;int, int&gt; (61, 87, 13);new SUndirectedTaggedEdge&lt;int, int&gt; (input_read, input_read+1, 0)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |39 -&gt; seq[new SUndirectedTaggedEdge&lt;int, int&gt; (39, 96, 8);new SUndirectedTaggedEdge&lt;int, int&gt; (input_read, input_read+1, 0)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |68 -&gt; seq[new SUndirectedTaggedEdge&lt;int, int&gt; (68, 93, 8);new SUndirectedTaggedEdge&lt;int, int&gt; (input_read, input_read+1, 0)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |98 -&gt; Seq.empty<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |input_read -&gt; seq[ new SUndirectedTaggedEdge&lt;int, int&gt; (input_read, input_read+1, 0)]<br>&nbsp;&nbsp;&nbsp; edge&nbsp;&nbsp; &nbsp;<br>&nbsp; //&nbsp; let link_squares (squares: List&lt;Rect&gt;) (output_chain:bool)<br><br>let getMEM_filter_simple () = <br>&nbsp;&nbsp;&nbsp; new TryFunc&lt;int, IEnumerable&lt;SUndirectedTaggedEdge&lt;int, int&gt;&gt;&nbsp; &gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fun i ([&lt;Out&gt;] res: byref &lt;IEnumerable&lt;SUndirectedTaggedEdge&lt;int, int&gt;&gt;&gt;&nbsp; ) -&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res &lt;-&nbsp;&nbsp; (chains_scores_1_read_simple&nbsp;&nbsp; i&nbsp; )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Printf.printf &quot;edges=%A\\n&quot; (Seq.to_array res)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not (Seq.isEmpty res))&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; &nbsp;<br><br>let build_graph ()= //: seq&lt;int * Array&lt;int&gt;&gt; ) =<br>&nbsp;&nbsp;&nbsp; let encoding=new System.Text.ASCIIEncoding()<br>&nbsp;&nbsp;&nbsp; let num_reads = 99<br>&nbsp;&nbsp;&nbsp; let edge_enum = getMEM_filter_simple ()<br>&nbsp;&nbsp;&nbsp; let graph = new DelegateUndirectedGraph&lt;int,SUndirectedTaggedEdge&lt;int, int&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((seq[0..num_reads - 1]), edge_enum, false)<br>&nbsp;&nbsp;&nbsp; let mst_edges = graph.MinimumSpanningTreeKruskal&nbsp; (fun key -&gt; -float (key.Tag)) <br>&nbsp;&nbsp;&nbsp; let mutable weight = 0<br>&nbsp;&nbsp;&nbsp; for edge in mst_edges do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weight &lt;- weight + edge.Tag<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Printf.printf &quot;Edge %A\\n&quot; edge<br><br>&nbsp;&nbsp;&nbsp; Printf.printf &quot;Total weight=%d\\n&quot; weight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>let _ = build_graph()</p>",
    "PostedDate": "2009-07-16T22:23:26.003-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]