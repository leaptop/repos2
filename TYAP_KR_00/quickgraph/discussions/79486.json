[
  {
    "Id": "272134",
    "ThreadId": "79486",
    "Html": "<p>I have a graph with&nbsp; 10649 Waypoints and 14158 connections and I'm currently using QuickGraph to calculate shortest route.</p>\r\n<p>Currently it takes ~300 ms on my reference test machine and I need to find every ms i can....</p>\r\n<p>I need to build the graph for each route since no two routes are based on the same net (and If they are, I'm caching the answer, so that quick enough).</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>AdjacencyGraph&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt; graph = <span style=\"color:Blue\">new</span> AdjacencyGraph&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt;(<span style=\"color:Blue\">true</span>);\r\n<br>I insert Vertexes with: (In a loop that desides what vertexes are valid for this graph)            </pre>\r\n</div>\r\n<p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre> graph.AddVertex(p.PortID);\r\n<br>I add the connection (right now bi directionaly, but that might change in the future)<br><div style=\"color:Black;background-color:White\"><pre>     Edge&lt;<span style=\"color:Blue\">string</span>&gt; e = <span style=\"color:Blue\">new</span> Edge&lt;<span style=\"color:Blue\">string</span>&gt;(C.FromID, C.ToID);\r\n     graph.AddEdge(e);\r\n     edgeCost.Add(e, C.Length); <span style=\"color:Green\">// Distance</span>\r\n\r\n     <span style=\"color:Green\">// to from -&gt; from to</span>\r\n    Edge&lt;<span style=\"color:Blue\">string</span>&gt; e2 = <span style=\"color:Blue\">new</span> Edge&lt;<span style=\"color:Blue\">string</span>&gt;(C.ToID, C.FromID);\r\n    graph.AddEdge(e2);\r\n    edgeCost.Add(e2, C.Length); <span style=\"color:Green\">// Distance</span>\r\n\r\n</pre>\r\n</div>\r\nThen I caluculate:<br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    DijkstraShortestPathAlgorithm&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt; dijkstra = <span style=\"color:Blue\">new</span> DijkstraShortestPathAlgorithm&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt;(graph, AlgorithmExtensions.GetIndexer&lt;Edge&lt;<span style=\"color:Blue\">string</span>&gt;, <span style=\"color:Blue\">double</span>&gt;(edgeCost));\r\n    QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt; predecessorObserver = <span style=\"color:Blue\">new</span> QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt;();\r\n    predecessorObserver.Attach(dijkstra);\r\n    VertexDistanceRecorderObserver&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt; distObserver = <span style=\"color:Blue\">new</span> VertexDistanceRecorderObserver&lt;<span style=\"color:Blue\">string</span>, Edge&lt;<span style=\"color:Blue\">string</span>&gt;&gt;(AlgorithmExtensions.GetIndexer&lt;Edge&lt;<span style=\"color:Blue\">string</span>&gt;, <span style=\"color:Blue\">double</span>&gt;(edgeCost));\r\n    distObserver.Attach(dijkstra);\r\n    dijkstra.Compute(FromPort);\r\n<br><br>Then I get the route:<pre>                predecessorObserver.TryGetPath(ToPort, <span style=\"color:Blue\">out</span> Path);\r\n</pre>\r\n</pre>\r\n</div>\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Is this, in a performance view, the fastest way to do this ? I was wondering if the boost library still had the upper hand performance wise ?</p>\r\n<p>Happy New year :)</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-01T00:27:07.193-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "290672",
    "ThreadId": "79486",
    "Html": "<p>Boost probably has the upper hand.</p>\r\n<p>* you do not need the distObserver in your example, which might save some cycles.<br>* use integers instead of string as vertices which will save more cycles<br>* If you know the number of vertices before hand, use an ArrayAdjacencyGraph which is a more compact and efficient representation</p>\r\n<p>Hope that helps.</p>",
    "PostedDate": "2010-02-14T14:40:16.21-08:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  }
]