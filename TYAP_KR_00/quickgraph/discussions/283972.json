[
  {
    "Id": "716427",
    "ThreadId": "283972",
    "Html": "\r\n<p>I am very interested in using this library, but have spent a good deal of time struggling with first obtaining it, then attempting to learn and use it.&nbsp; There seem to be many requests on this discussion forum for complete samples, which go unanswered.&nbsp;&nbsp;\r\n Most of the code posted, when there is a reply, is not complete.&nbsp; Is there a particular reason and philosophy for not providing fully worked simple examples for those of us who are beginners and operate best from such a starting point?&nbsp; Am I missing\r\n the location of some library of examples?</p>\r\n<p>Thanks.</p>\r\n<p>R. Males</p>\r\n<p>Cincinnati, Ohio, USA</p>\r\n",
    "PostedDate": "2011-12-22T21:39:04.873-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "716517",
    "ThreadId": "283972",
    "Html": "<p>This is obviously something for the author to answer.</p>\r\n<p>My guess is that QuickGraph has always been a side project.</p>\r\n<p>I doubt the author was ever paid to work on it, or anybody else.</p>\r\n<p>It is up to us to provide any missing bits (code, documentation, any other form of help).</p>\r\n<p>This is true for many other open source projects.</p>",
    "PostedDate": "2011-12-23T02:11:08.26-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "716644",
    "ThreadId": "283972",
    "Html": "<p>I agree, and should I ever get a simple solution working in my environment (Visual Studio 2010 Express), I will post it, together with an explanation.</p>\r\n<p>&nbsp;</p>\r\n<p>Dick</p>",
    "PostedDate": "2011-12-23T08:02:13.083-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "745226",
    "ThreadId": "283972",
    "Html": "<p>Here is a fully worked sample in VS 2010 Express.</p>\r\n<p>using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br /><br />using QuickGraph;<br />using QuickGraph.Collections;<br />using QuickGraph.Algorithms;<br />using QuickGraph.Algorithms.ShortestPath;<br />using QuickGraph.Algorithms.Observers;<br /><br /><br />// Sample code for use of QuickGraph<br />// Assembled from various code snippets found in discussions and documentation<br />// thanks to those who posted<br />// Needs QuickGraph dll<br />// Add reference to QuickGraph<br />// R. Males 2012<br /><br />namespace QuickGraphTest<br />{<br />&nbsp;&nbsp;&nbsp; class QuickGraphSimpleTest1<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use simple adjacency graph<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt; graph = new AdjacencyGraph&lt;string, Edge&lt;string&gt;&gt;(true);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add some vertices to the graph<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"A\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"B\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"C\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"D\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"E\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"F\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"G\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"H\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"I\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddVertex(\"J\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create the edges (&lt;string&gt; -&gt; the edge is identified by a string value)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; a_e = new Edge&lt;string&gt;(\"A\", \"E\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; e_f = new Edge&lt;string&gt;(\"E\", \"F\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; f_g = new Edge&lt;string&gt;(\"F\", \"G\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; g_h = new Edge&lt;string&gt;(\"G\", \"H\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; a_b = new Edge&lt;string&gt;(\"A\", \"B\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; b_c = new Edge&lt;string&gt;(\"B\", \"C\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; c_d = new Edge&lt;string&gt;(\"C\", \"D\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; d_e = new Edge&lt;string&gt;(\"D\", \"E\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; e_h = new Edge&lt;string&gt;(\"E\", \"H\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; h_i = new Edge&lt;string&gt;(\"H\", \"I\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; i_j = new Edge&lt;string&gt;(\"I\", \"J\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Edge&lt;string&gt; j_a = new Edge&lt;string&gt;(\"J\", \"A\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add the edges<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(a_e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(e_f);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(f_g);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(g_h);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(a_b);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(b_c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(c_d);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(d_e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(e_h);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(h_i);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(i_j);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph.AddEdge(j_a);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nGraph Edges\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var vertex in graph.Vertices)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var edge in graph.OutEdges(vertex))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(edge);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Define some lengths to the edges<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dictionary&lt;Edge&lt;string&gt;, double&gt; edgeCost = new Dictionary&lt;Edge&lt;string&gt;, double&gt;(graph.EdgeCount);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(a_e, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(e_f, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(f_g, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(g_h, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(a_b, 1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(b_c, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(c_d, 2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(d_e, 3);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(e_h, 4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(h_i, 1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(i_j, 2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.Add(j_a, 3);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nEdge Costs\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var x in edgeCost)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"Edge {0} Cost {1}\", x.Key, x.Value);<br /><br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use Dijkstra shortest path algorithm.&nbsp;&nbsp; Note passing the edge cost dictionary<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt; dijkstra = new DijkstraShortestPathAlgorithm&lt;string, Edge&lt;string&gt;&gt;(graph, AlgorithmExtensions.GetIndexer&lt;Edge&lt;string&gt;, double&gt;(edgeCost));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // creating some observers to get output after the computation<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Attach a Vertex Predecessor Recorder Observer to give us the paths<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt; predecessorObserver = new QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; predecessorObserver.Attach(dijkstra);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add a path recorder observer<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver&lt;string, Edge&lt;string&gt;&gt; predecessorPathRecorderObserver = new QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver&lt;string, Edge&lt;string&gt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; predecessorPathRecorderObserver.Attach(dijkstra);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and another observer<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt; distObserver = new VertexDistanceRecorderObserver&lt;string, Edge&lt;string&gt;&gt;(AlgorithmExtensions.GetIndexer&lt;Edge&lt;string&gt;, double&gt;(edgeCost));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; distObserver.Attach(dijkstra);<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // compute paths from vertex A<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dijkstra.Compute(\"A\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // report out what the observers contain, just to see what they do<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nPredecessor Observer\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var z in predecessorObserver.VertexPredecessors)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\" Vertex Predecessor key:{0} value:{1}\", z.Key, z.Value);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nPath Recorder Observer\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var xx in predecessorPathRecorderObserver.VertexPredecessors)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\" EndPathVertices {0} \", xx.ToString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nDistance Observer\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (KeyValuePair&lt;string, double&gt; kvp in distObserver.Distances)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"Distance from root to node {0} is {1}\", kvp.Key, kvp.Value);<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get path from root to node I, working backwards, using the predecessor observer<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // note that total costs for path should agree with those above from distance observer<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nShow Path and Cost\\n\");<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;Edge&lt;string&gt;&gt; outpath;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var endVertex in graph.Vertices)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\nPath to End Vertex {0}\\n\", endVertex);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool validPath = predecessorObserver.TryGetPath(endVertex, out outpath);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (validPath)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pathCount = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double totalPathCost = 0.0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double costForEdge;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\" \");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var zzz in outpath)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeCost.TryGetValue(zzz, out costForEdge);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; totalPathCost += costForEdge;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"\\tStep {0} {1} edge cost {2} total path cost {3}\", pathCount++, zzz.ToString(), costForEdge, totalPathCost);<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(\"Press &lt;ENTER&gt; to complete\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadKey();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br />}<br /><br /><br /></p>\r\n<p>and the output is as follows:</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>Graph Edges<br /><br />A-&gt;E<br />A-&gt;B<br />B-&gt;C<br />C-&gt;D<br />D-&gt;E<br />E-&gt;F<br />E-&gt;H<br />F-&gt;G<br />G-&gt;H<br />H-&gt;I<br />I-&gt;J<br />J-&gt;A<br /><br />Edge Costs<br /><br />Edge A-&gt;E Cost 1<br />Edge E-&gt;F Cost 1<br />Edge F-&gt;G Cost 1<br />Edge G-&gt;H Cost 1<br />Edge A-&gt;B Cost 1<br />Edge B-&gt;C Cost 1<br />Edge C-&gt;D Cost 2<br />Edge D-&gt;E Cost 3<br />Edge E-&gt;H Cost 4<br />Edge H-&gt;I Cost 1<br />Edge I-&gt;J Cost 2<br />Edge J-&gt;A Cost 3<br /><br />Predecessor Observer<br /><br />&nbsp;Vertex Predecessor key:E value:A-&gt;E<br />&nbsp;Vertex Predecessor key:B value:A-&gt;B<br />&nbsp;Vertex Predecessor key:F value:E-&gt;F<br />&nbsp;Vertex Predecessor key:H value:G-&gt;H<br />&nbsp;Vertex Predecessor key:C value:B-&gt;C<br />&nbsp;Vertex Predecessor key:G value:F-&gt;G<br />&nbsp;Vertex Predecessor key:D value:C-&gt;D<br />&nbsp;Vertex Predecessor key:I value:H-&gt;I<br />&nbsp;Vertex Predecessor key:J value:I-&gt;J<br /><br />Path Recorder Observer<br /><br />&nbsp;EndPathVertices [E, A-&gt;E]<br />&nbsp;EndPathVertices [B, A-&gt;B]<br />&nbsp;EndPathVertices [F, E-&gt;F]<br />&nbsp;EndPathVertices [H, G-&gt;H]<br />&nbsp;EndPathVertices [C, B-&gt;C]<br />&nbsp;EndPathVertices [G, F-&gt;G]<br />&nbsp;EndPathVertices [D, C-&gt;D]<br />&nbsp;EndPathVertices [I, H-&gt;I]<br />&nbsp;EndPathVertices [J, I-&gt;J]<br /><br />Distance Observer<br /><br />Distance from root to node A is 0<br />Distance from root to node E is 1<br />Distance from root to node B is 1<br />Distance from root to node F is 2<br />Distance from root to node H is 4<br />Distance from root to node C is 2<br />Distance from root to node G is 3<br />Distance from root to node D is 4<br />Distance from root to node I is 5<br />Distance from root to node J is 7<br /><br />Show Path and Cost<br /><br /><br />Path to End Vertex A<br /><br /><br />Path to End Vertex B<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;B edge cost 1 total path cost 1<br /><br />Path to End Vertex C<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;B edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 B-&gt;C edge cost 1 total path cost 2<br /><br />Path to End Vertex D<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;B edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 B-&gt;C edge cost 1 total path cost 2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 2 C-&gt;D edge cost 2 total path cost 4<br /><br />Path to End Vertex E<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br /><br />Path to End Vertex F<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 E-&gt;F edge cost 1 total path cost 2<br /><br />Path to End Vertex G<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 E-&gt;F edge cost 1 total path cost 2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 2 F-&gt;G edge cost 1 total path cost 3<br /><br />Path to End Vertex H<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 E-&gt;F edge cost 1 total path cost 2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 2 F-&gt;G edge cost 1 total path cost 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 3 G-&gt;H edge cost 1 total path cost 4<br /><br />Path to End Vertex I<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 E-&gt;F edge cost 1 total path cost 2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 2 F-&gt;G edge cost 1 total path cost 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 3 G-&gt;H edge cost 1 total path cost 4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 4 H-&gt;I edge cost 1 total path cost 5<br /><br />Path to End Vertex J<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 0 A-&gt;E edge cost 1 total path cost 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 1 E-&gt;F edge cost 1 total path cost 2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 2 F-&gt;G edge cost 1 total path cost 3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 3 G-&gt;H edge cost 1 total path cost 4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 4 H-&gt;I edge cost 1 total path cost 5<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Step 5 I-&gt;J edge cost 2 total path cost 7<br />Press &lt;ENTER&gt; to complete</p>",
    "PostedDate": "2012-02-07T07:21:38.02-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1005368",
    "ThreadId": "283972",
    "Html": "Thanks they are really helpful examples.\r<br />\n<br />\nFor a mere mortal line of business developer like myself this library looks very promising but it's a huge learning curve.\r<br />\n<br />\nOnce I've got my head around everything, I may join in the phone do some getting started guides as well.\r<br />\n<br />\nThanks again.<br />\n",
    "PostedDate": "2013-02-22T11:04:55.693-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]