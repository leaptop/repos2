[
  {
    "Id": "452262",
    "ThreadId": "215131",
    "Html": "hey, i make a code of bellmanford in java applet\r\nbut the compiler shows  reached end of file while parsing error...but i cant find any error..\r\ni ve close my braces properly...\r\nplz anyone help me to identify my error.....plz\r\nmy code is given bellow...\r\n\r\n\r\nimport java.awt.*;\r\nimport java.applet.*;\r\n\r\npublic class GraphAlgorithm extends Applet {\r\n\tGraphCanvas graphcanvas = new GraphCanvas(this);\r\n\tOptions options = new Options(this);\r\n\tDocumentation documentation = new Documentation();\r\n\t\r\n\tpublic void init() {\r\n\t\tsetLayout(new BorderLayout(10, 10));\r\n\t\tadd(&quot;Center&quot;, graphcanvas);\r\n\t\tadd(&quot;East&quot;, options);\r\n\t}\r\n\t\r\n\tpublic Insets insets(){\r\n\t\treturn new Insets(10, 10, 10, 10);\r\n\t}\r\n\t\r\n\tpublic void lock(){\r\n\t\tgraphcanvas.lock();\r\n\t\toptions.lock();\r\n\t}\r\n\t\r\n\tpublic void unlock(){\r\n\t\tgraphcanvas.unlock();\r\n\t\toptions.unlock();\r\n\t}\r\n}\r\n\r\nclass Options extends Panel{\r\n\tButton b1 = new Button(&quot;clear&quot;);\r\n\tButton b2 = new Button(&quot;run&quot;);\r\n\tButton b3 = new Button(&quot;step&quot;);\r\n    Button b4 = new Button(&quot;reset&quot;);\r\n    Button b5 = new Button(&quot;exit&quot;);\r\n    GraphAlgorithm parent;\r\n    boolean locked=false;\r\n\r\n   Options(GraphAlgorithm myparent){\r\n   \t  parent = myparent;\r\n   \t  setLayout(new GraidLayout(6, 1, 0, 10));\r\n   \t  add(b1);\r\n   \t  add(b2);\r\n   \t  add(b3);\r\n   \t  add(b4);\r\n   \t  add(b5);\r\n   }\r\n   \r\n   public boolean action(Event evt, Object arg){\r\n   \t   if(evt.target instanceof Button){\r\n   \t   \tif(((String)arg).equals(&quot;step&quot;)){\r\n   \t   \t\tif(!locked){\r\n   \t   \t\t\tb3.setLabel(&quot;next step&quot;);\r\n   \t   \t\t\tparent.graphcanvas.stepalg();\r\n   \t   \t\t}\r\n   \t   \t\telse parent.documentation.doctext.showline(&quot;locked&quot;);\r\n   \t   \t}\r\n   \t   \tif(((String)arg).equals(&quot;next step&quot;)){\r\n   \t   \t\tparent.graphcanvas.nextstep();\r\n   \t    if(((String)arg).equals(&quot;reset&quot;)){\r\n   \t    \tparent.graphcanvas.reset();\r\n   \t    \tb3.setLabel(&quot;step&quot;);\r\n   \t    \tparent.documentation.doctext.showline(&quot;all times&quot;);\r\n   \t    \t   \t   \t\r\n   \t    }\r\n   \t    if(((String)arg).equals(&quot;clear&quot;)){\r\n   \t    \tparent.graphcanvas.clear();\r\n   \t    \tb3.setLabel(&quot;step&quot;);\r\n   \t    \tparent.documentation.doctext.showline(&quot;all times&quot;);\r\n   \t    }\r\n   \t    if(((String)arg).equals(&quot;run&quot;)){\r\n   \t    \tif(!locked)\r\n   \t    \t\tparent.graphcanvas.runalg();\r\n   \t    \telse parent.documentation.doctext.showline(&quot;locked&quot;);\r\n   \t    }\r\n   \t    if(((String)arg).equals(&quot;exit&quot;)){\r\n   \t    \tSystem.exit(0);\r\n   \t    }\r\n   \t   }\r\n   \t   return true;\r\n   }\r\n   \r\n   lock();{ \r\n   \t Locked=true;\r\n   }\r\n   \r\n   unlock();{\r\n   \t Locked=false;\r\n   \t b3.setLabel(&quot;step&quot;);\r\n   }\r\n}\r\n\r\nclass Documentation extends Panel{\r\n\tDocOptions docopt = new DocOptions(this);\r\n\tDocText doctext = new DocText();\r\n\t\r\n\tDocumentation(){\r\n\t\tsetLayout(new BorderLayout(10, 10));\r\n\t\tadd(&quot;West&quot;, docopt);\r\n\t\tadd(&quot;Center&quot;, doctext);\r\n\t}\r\n}\r\n\r\nclass DocOptions extends Panel{\r\n\tChoice doc = new Choice();\r\n\tDocumentation parent;\r\n\t\r\n\tDocOptions(Documentation myparent){\r\n\t\tsetLayout(new GridLayout(2, 1, 5, 0));\r\n\t\tparent = myparent;\r\n\t\tadd(new Label(&quot;Documentation:&quot;));\r\n\t\tdoc.addItem(&quot;draw nodes&quot;);\r\n\t\tdoc.addItem(&quot;remove nodes&quot;);\r\n\t\tdoc.addItem(&quot;move nodes&quot;);\r\n\t\tdoc.addItem(&quot;startnode&quot;);\r\n\t\tdoc.addItem(&quot;draw arrow&quot;);\r\n\t\tdoc.addItem(&quot;remove arrow&quot;);\r\n\t\tdoc.addItem(&quot;change weights&quot;);\r\n\t\tdoc.addItem(&quot;clear/reset&quot;);\r\n\t\tdoc.addItem(&quot;run algorithm&quot;);\r\n\t\tdoc.addItem(&quot;step through&quot;);\r\n\t\tdoc.addItem(&quot;example&quot;);\r\n\t\tdoc.addItem(&quot;exit&quot;);\r\n\t\tdoc.addItem(&quot;add items&quot;);\r\n\t\tadd(doc);\t\r\n\t}\r\n\t\r\n\tpublic boolean action(Event evt, Object arg){\r\n\t\tif(evt.target){\r\n\t\t\tString str = new String(doc.getSelectedItem());\r\n\t\t\tparent.doctext.showline(str);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nclass DocText extends TextArea{\r\n\tfinal String drawnodes = new String(&quot;DRAWING NODES:\\n&quot; + &quot;Draw a node by clicking the mouse.\\n\\n&quot;);\r\n    final String rmvnodes = new String(&quot;REMOVE NODES:\\n&quot; + &quot;Select a node except start node,press &lt;ctrl&gt; and click on the node.\\n\\n&quot;);\r\n    final String mvnodes = new String(&quot;MOVE NODES:\\n&quot; + &quot; To move a node press &lt;Shift&gt;, click on the node,and drag it to.\\n\\n&quot;);\r\n    final String startnode = new String(&quot;START NODE:\\n&quot;+&quot;The startnode is blue, other nodes are grey.\\n&quot;);\r\n    final String drawarrows = new String(&quot;DRAWING ARROWS:\\n&quot;+&quot;To draw an arrow click mouse in a node,&quot;+&quot;and drag it to another node.\\n\\n&quot;);\r\n    final String rmvarrows = new String(&quot;REMOVE ARROWS:\\n&quot;+&quot;To remove an arrow, change its weight to 0.\\n\\n&quot;);\r\n    final String weight = new String(&quot;CHANGING WEIGHTS:\\n&quot;+&quot;To change the weight of an arrow, click on the arrowhead and drag\\n&quot;+&quot;it along the arrow.\\n\\n&quot;);\r\n    final String clrreset = new String(&quot;&lt;CLEAR&gt; BUTTON: &quot;+&quot;Remove the current graph from the screen.\\n&quot;+&quot;&lt;RESET&gt; BUTTON: &quot;);\r\n    final String runalg = new String(&quot;&lt;RUN&gt; BUTTON: &quot;+&quot;Run the algorithm on the graph, there will be a time\\n&quot; + &quot;To run the algorithm slower, use &lt;STEP&gt;.\\n&quot;);\r\n    final String step = new String(&quot;&lt;STEP&gt; BUTTON: &quot; +&quot;An opportunity to step through the algorithm.\\n&quot;);\r\n    final String example = new String(&quot;&lt;EXAMPLE&gt; BUTTON: &quot;+&quot;Displays a graph on the screen for you.\\n&quot;+&quot;You can then use &lt;STEP&gt; or &lt;RUN&gt;\\n&quot;);\r\n    final String exitbutton = new String(&quot;&lt;EXIT&gt; BUTTON: &quot; +&quot;Only works if applet is run with appletviewer.\\n&quot;);\r\n    final String toclose = new String(&quot;ERROR: &quot;+&quot;This position is to close to another node/arrow.\\n&quot;);\r\n    final String done = new String(&quot;Algorithm has finished, &quot; + &quot;follow orange arrows from startnode to any node &quot; + &quot;press &lt;RESET&gt; to reset the graph, and unlock the screen.&quot;);\r\n    final String some = new String(&quot;Algorithm has finished, &quot; + &quot;follow orange arrows from startnode to any node &quot;+  &quot;press &lt;RESET&gt; to reset the graph, and unlock the screen.&quot;);\r\n    final String none = new String(&quot;Algorithm has finished, &quot; +&quot;there are no nodes reachable from the start node.\\n&quot;+&quot;press &lt;RESET&gt; to reset the graph, and unlock the screen.&quot;);\r\n    final String maxnodes = new String(&quot;ERROR: &quot;+&quot;Maximum number of nodes reached!\\n\\n&quot;);\r\n    final String info = new String(&quot;DOCUMENTATION:\\n&quot;+&quot;You can scroll through the documentation or get documentation\\n&quot;+&quot; to the scrolling text.\\n\\n&quot;); \r\n    final String locked = new String(&quot;ERROR: &quot;+&quot;Keyboard/mouse locked for this action.\\n&quot;+&quot;Either press &lt;NEXT STEP&gt; or &lt;RESET&gt;.\\n&quot;); \r\n    final String doc = info + drawnodes + rmvnodes + mvnodes + startnode + drawarrows + weight + rmvarrows + clrreset + runalg + step + example + exitbutton;    \r\n\r\n    \r\n    DocText(){\r\n    \tsuper(5,2);\r\n    \tsetText(doc);\r\n    }\r\n    \r\n    public void showline(String str) {\r\n\r\n\tif (str.equals(&quot;draw nodes&quot;))              setText(drawnodes);\r\n\r\n\telse if (str.equals(&quot;remove nodes&quot;))       setText(rmvnodes);\r\n\r\n\telse if (str.equals(&quot;move nodes&quot;))         setText(mvnodes);\r\n\r\n\telse if (str.equals(&quot;the startnode&quot;))      setText(startnode);\r\n\r\n\telse if (str.equals(&quot;draw arrows&quot;))        setText(drawarrows);\r\n\r\n\telse if (str.equals(&quot;change weights&quot;))     setText(weight);\r\n\r\n\telse if (str.equals(&quot;remove arrows&quot;))      setText(rmvarrows);\r\n\r\n\telse if (str.equals(&quot;clear / reset&quot;))      setText(clrreset);\r\n\r\n\telse if (str.equals(&quot;run algorithm&quot;))      setText(runalg);\r\n\r\n\telse if (str.equals(&quot;step through&quot;))       setText(step);\r\n\r\n\telse if (str.equals(&quot;example&quot;))            setText(example); \r\n\r\n    else if (str.equals(&quot;exit&quot;))               setText(exitbutton);\r\n\r\n\telse if (str.equals(&quot;all items&quot;))          setText(doc);\r\n\r\n\telse if (str.equals(&quot;toclose&quot;))            setText(toclose); \r\n\r\n\telse if (str.equals(&quot;done&quot;))               setText(done);   \r\n\r\n\telse if (str.equals(&quot;locked&quot;))             setText(locked);\r\n\r\n\telse if (str.equals(&quot;maxnodes&quot;))           setText(maxnodes);       \r\n\r\n    else if (str.equals(&quot;none&quot;))               setText(none);   \r\n\r\n    else if (str.equals(&quot;some&quot;))               setText(some);   \r\n\r\n\telse setText(str);\r\n\r\n    }\r\n}\r\n\r\nclass GraphCanves extends Canvas implements Runnable{\r\n\tfinal int MAXNODES = 10;\r\n\r\n    final int MAX = MAXNODES+1;\r\n\r\n    final int NODESIZE = 10;\r\n\r\n    final int NODERADIX = 13;\r\n\r\n    final int BELLMANFORD = -1;\r\n    \r\n    \r\n    \r\n    Point node[] = new Point[MAX];\r\n\r\n    int weight[][] = new int[MAX][MAX];\r\n\r\n    Point arrow[][] = new Point[MAX][MAX];\r\n\r\n    Point startp[][] = new Point[MAX][MAX];\r\n\r\n    Point endp[][] = new Point[MAX][MAX];\r\n\r\n    float dir_x[][] = new float[MAX][MAX]; \r\n\r\n    float dir_y[][] = new float[MAX][MAX]; \r\n\r\n    boolean algedge[][] = new boolean[MAX][MAX];\r\n    int dist[] = new int[MAX];\r\n    int finaldist[] = new int[MAX];\r\n    Color colornode[] = new Color[MAX];\r\n    boolean changed[] = new boolean[MAX];   \r\n    int numchanged =0; \r\n    int neighbours=0;\r\n     \r\n    int step=0;\r\n    int mindist, minnode, minstart, minend;\r\n\r\n\r\n\r\n    int numnodes=0;      \r\n\r\n    int emptyspots=0;    \r\n\r\n    int startgraph=0; \r\n\r\n    int hitnode;\r\n\r\n    int node1, node2;\r\n\r\n\r\n\r\n    Point thispoint=new Point(0,0);\r\n\r\n    Point oldpoint=new Point(0, 0);\r\n    \r\n    boolean newarrow = false;\r\n\r\n    boolean movearrow = false;\r\n\r\n    boolean movestart = false;\r\n\r\n    boolean deletenode = false;\r\n\r\n    boolean movenode = false;\r\n\r\n    boolean performalg = false;\r\n\r\n    boolean clicked = false;\r\n\r\n\r\n    Font roman= new Font(&quot;TimesRoman&quot;, Font.BOLD, 12);\r\n\r\n    Font helvetica= new Font(&quot;Helvetica&quot;, Font.BOLD, 15);\r\n\r\n    FontMetrics fmetrics = getFontMetrics(roman);\r\n\r\n    int h = (int)fmetrics.getHeight()/3;\r\n\r\n\r\n    private Image offScreenImage;\r\n\r\n    private Graphics offScreenGraphics;\r\n\r\n    private Dimension offScreenSize;\r\n\r\n\r\n    Thread algrthm;\r\n\r\n    int algorithm;\r\n    \r\n    String showstring = new String(&quot;&quot;);\r\n\r\n    boolean stepthrough=false;\r\n\r\n    boolean Locked = false;\r\n\r\n\r\n    GraphAlgorithm parent;\r\n\r\n\r\n   void GraphCanvas(GraphAlgorithm myparent) {\r\n\r\n\tparent = myparent;\r\n\r\n\tinit();\r\n\talgorithm = BELLMANFORD;\r\n\t\r\n\tsetBackground(Color.cyan);\r\n}\r\n\r\n\r\npublic void lock() {\r\n\t\r\n\tLocked=true;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void unlock() {\r\n\r\n\tLocked=false;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void start() {\r\n\r\n\tif (algrthm != null) algrthm.resume();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void init() {\r\n\r\n\tfor (int i=0;i&lt;MAXNODES;i++) {\r\n\r\n\t  colornode[i]=Color.gray;\r\n\r\n\t  for (int j=0; j&lt;MAXNODES;j++)\r\n\r\n\t      algedge[i][j]=false;\r\n\r\n\t}\r\n\r\n\tcolornode[startgraph]=Color.blue;\r\n\r\n\tperformalg = false;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void clear() {\r\n\r\n    startgraph=0;\r\n\r\n\tnumnodes=0;\r\n\r\n\temptyspots=0;\r\n\r\n\tinit();\r\n\r\n\tfor(int i=0; i&lt;MAXNODES; i++) {\r\n\r\n\t  node[i]=new Point(0, 0);\r\n\r\n\t  for (int j=0; j&lt;MAXNODES;j++)\r\n\r\n\t      weight[i][j]=0;\r\n\r\n\t}\r\n\r\n\tif (algrthm != null) algrthm.stop();\r\n\r\n\tparent.unlock();\r\n\r\n\trepaint();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void reset() {\r\n\t\r\n\tinit();\r\n\r\n\tif (algrthm != null) algrthm.stop();\r\n\r\n\tparent.unlock();\r\n\r\n\trepaint();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void runalg() {\r\n\t\r\n\tparent.lock();\r\n\r\n\tinitalg();\r\n\r\n\tperformalg = true;\r\n\r\n\talgrthm = new Thread(this);\r\n\r\n\talgrthm.start();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void stepalg() {\r\n\t\r\n\tparent.lock();\r\n\r\n\tinitalg();\r\n\r\n\tperformalg = true;\r\n\r\n\tnextstep();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void initalg() {\r\n\r\n\tinit();\r\n\r\n\tfor(int i=0; i&lt;MAXNODES; i++) {\r\n\r\n\t  dist[i]=-1;\r\n\r\n\t  finaldist[i]=-1;\r\n\r\n\t  for (int j=0; j&lt;MAXNODES;j++)\r\n\r\n              algedge[i][j]=false;\r\n\r\n\t}\r\n\r\n    dist[startgraph]=0;\r\n\r\n\tfinaldist[startgraph]=0;\r\n\r\n\tstep=0;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void nextstep() {\r\n     \r\n    finaldist[minend]=mindist;\r\n\r\n\talgedge[minstart][minend]=true;\r\n\r\n\tcolornode[minend]=Color.orange;\r\n\t\r\n\tstep++;\r\n\r\n\trepaint();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void stop() {\r\n\r\n\tif (algrthm != null) algrthm.suspend();\r\n\r\n    }\r\n\r\n\r\n\r\n    public void run() {\r\n\r\n\tfor(int i=0; i&lt;(numnodes-emptyspots); i++){\r\n\r\n\t  nextstep();\r\n\r\n\t  try { algrthm.sleep(2000); }\r\n\r\n\t  catch (InterruptedException e) {}\r\n\r\n\t}\r\n\r\n\talgrthm = null;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void showexample() {\r\n\t\r\n\tint w, h;\r\n\r\n\tclear();\r\n\r\n\tinit();\r\n\r\n\tnumnodes=10;\r\n\r\n\temptyspots=0;\r\n\r\n\tfor(int i=0; i&lt;MAXNODES; i++) {\r\n\r\n\t  node[i]=new Point(0, 0);\r\n\r\n\t  for (int j=0; j&lt;MAXNODES;j++)\r\n\r\n\t      weight[i][j]=0;\r\n\r\n\t}\r\n\r\n\tw=this.size().width/8;\r\n\r\n\th=this.size().height/8;\r\n\r\n\tnode[0]=new Point(w, h);     node[1]=new Point(3*w, h);   \r\n\r\n\tnode[2]=new Point(5*w, h);   node[3]=new Point(w, 4*h); \r\n\r\n\tnode[4]=new Point(3*w, 4*h); node[5]=new Point(5*w, 4*h);\r\n\r\n\tnode[6]=new Point(w, 7*h);   node[7]=new Point(3*w, 7*h); \r\n\r\n\tnode[8]=new Point(5*w, 7*h); node[9]=new Point(7*w, 4*h);\r\n\r\n\r\n\r\n\tweight[0][1]=4;  weight[0][3]=1;\r\n\r\n\tweight[1][0]=74; weight[1][2]=2; weight[1][4]=12;\r\n\r\n\tweight[2][5]=74; weight[2][1]=12; weight[2][9]=12;\r\n\r\n\tweight[3][4]=32; weight[3][6]=22;\r\n\r\n\tweight[4][3]=66; weight[4][5]=76; weight[4][7]=33;\r\n\r\n\tweight[5][8]=11; weight[5][9]=21;\r\n\r\n\tweight[6][7]=10; weight[6][3]=12;\r\n\r\n\tweight[7][6]=2;  weight[7][8]=72;\r\n\r\n\tweight[8][5]=31; weight[8][9]=7; weight[8][7]=18;\r\n\r\n\tweight[9][5]=8;\r\n\r\n\r\n\r\n\tfor (int i=0;i&lt;numnodes;i++)\r\n\r\n\t   for (int j=0;j&lt;numnodes;j++)\r\n\r\n\t      if (weight[i][j]&gt;0)\r\n\r\n\t         arrowupdate(i, j, weight[i][j]);\r\n\r\n\r\n\r\n\trepaint();\r\n\r\n    }\r\n\r\n\r\n\r\n    public boolean mouseDown(Event evt, int x, int y) {\r\n\r\n\t\r\n\r\n\tif (Locked)\r\n\r\n\t    parent.documentation.doctext.showline(&quot;locked&quot;);\r\n\r\n\telse {\r\n\r\n\t  clicked = true;\r\n\r\n\t  if (evt.shiftDown()) {\r\n\t     \r\n\t     if (nodehit(x, y, NODESIZE)) {\r\n\r\n\t        oldpoint = node[hitnode];\r\n\r\n\t        node1 = hitnode;\r\n\r\n\t        movenode=true;\r\n\r\n\t     }\r\n\r\n\t  }\r\n\r\n\t  else if (evt.controlDown()) {\r\n\t     \r\n\t     if (nodehit(x, y, NODESIZE)) {\r\n\r\n\t        node1 = hitnode;\r\n\r\n\t        if (startgraph==node1) {\r\n\r\n\t           movestart=true;\r\n\r\n\t           thispoint = new Point(x,y);\r\n\r\n                   colornode[startgraph]=Color.gray;\r\n\r\n\t        }\r\n\r\n\t        else\r\n\r\n\t           deletenode= true;\r\n\r\n\t     }\r\n\r\n\t  }\r\n\r\n\t  else if (arrowhit(x, y, 5)) {\r\n\t     \r\n\t     movearrow = true;\r\n\r\n\t     repaint();\r\n\r\n\t  }\r\n\r\n\t  else if (nodehit(x, y, NODESIZE)) {\r\n\t     \r\n\t     if (!newarrow) {\r\n\r\n\t        newarrow = true;\r\n\r\n\t        thispoint = new Point(x, y);\r\n\r\n\t        node1 = hitnode;\r\n\r\n\t     }\r\n\r\n\t   }\r\n\r\n\t   else if ( !nodehit(x, y, 50) && !arrowhit(x, y, 50) )  {\r\n\t      if (emptyspots==0) {\r\n\t         if (numnodes &lt; MAXNODES)\r\n\r\n\t            node[numnodes++]=new Point(x, y);\r\n\r\n\t         else  parent.documentation.doctext.showline(&quot;maxnodes&quot;);\r\n\r\n\t      }\r\n\r\n\t      else {\r\n\t         int i;\r\n\r\n\t         for (i=0;i&lt;numnodes;i++)\r\n\r\n\t            if (node[i].x==-100) break;\r\n\r\n\t         node[i]=new Point(x, y);\r\n\r\n\t         emptyspots--;\r\n\r\n\t      }\r\n\r\n\t   }\r\n\r\n\t   else\r\n\t      parent.documentation.doctext.showline(&quot;toclose&quot;);\r\n\r\n\t   repaint();\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n    }\r\n\r\n\r\n\r\n    public boolean mouseDrag(Event evt, int x, int y) {\r\n\r\n\tif ( (!Locked) && clicked ) {\r\n\r\n\t   if (movenode) {\r\n\t      node[node1]=new Point(x, y);\r\n\r\n\t      for (int i=0;i&lt;numnodes;i++) {\r\n\r\n\t         if (weight[i][node1]&gt;0) {\r\n\r\n\t            arrowupdate(i, node1, weight[i][node1]);\r\n\r\n\t         }\r\n\r\n\t         if (weight[node1][i]&gt;0) {\r\n\r\n\t            arrowupdate(node1, i, weight[node1][i]);\r\n\r\n\t         }\r\n\r\n\t      }\r\n\r\n\t      repaint();\r\n\r\n\t   }\r\n\r\n\t   else if (movestart || newarrow) {\r\n\r\n\t      thispoint = new Point(x, y);\r\n\r\n\t      repaint();\r\n\r\n\t   }\r\n\r\n\t   else if (movearrow) {\r\n\r\n\t      changeweight(x, y);\r\n\r\n\t      repaint();\r\n\r\n\t   }\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public boolean mouseUp(Event evt, int x, int y) {\r\n\r\n\tif ( (!Locked) && clicked ) {\r\n\r\n\t   if (movenode) {\r\n\t      node[node1]=new Point(0, 0);\r\n\r\n\t      if ( nodehit(x, y, 50) || (x&lt;0) || (x&gt;this.size().width) || \r\n\r\n\t\t\t\t\t  (y&lt;0) || (y&gt;this.size().height) ) {\r\n\r\n\t         node[node1]=oldpoint;\r\n\r\n\t         parent.documentation.doctext.showline(&quot;toclose&quot;);\r\n\r\n\t      }\r\n\r\n\t      else node[node1]=new Point(x, y);\r\n\r\n\t      for (int i=0;i&lt;numnodes;i++) {\r\n\r\n\t         if (weight[i][node1]&gt;0)\r\n\r\n\t            arrowupdate(i, node1, weight[i][node1]);\r\n\r\n\t         if (weight[node1][i]&gt;0) \r\n\r\n\t            arrowupdate(node1, i, weight[node1][i]);\r\n\r\n\t      }\r\n\r\n\t      movenode=false;\r\n\r\n\t   }\r\n\r\n\t   else if (deletenode) {\r\n\r\n\t      nodedelete();\r\n\r\n\t      deletenode=false;\r\n\r\n\t   }\r\n\r\n\t   else if (newarrow) {\r\n\r\n\t      newarrow = false;\r\n\r\n\t      if (nodehit(x, y, NODESIZE)) {\r\n\r\n\t         node2=hitnode;\r\n\r\n\t         if (node1!=node2) {\r\n\r\n\t            arrowupdate(node1, node2, 50);\r\n\r\n\t            if (weight[node2][node1]&gt;0) {\r\n\r\n\t               arrowupdate(node2, node1, weight[node2][node1]);\r\n\r\n\t            }\r\n\r\n\t            parent.documentation.doctext.showline(&quot;change weights&quot;);\r\n\r\n\t         }\r\n\r\n\t         else System.out.println(&quot;zelfde&quot;);\r\n\r\n\t      }\r\n\r\n\t   }\r\n\r\n\t   else if (movearrow) {\r\n\r\n\t      movearrow = false;\r\n\r\n\t      if (weight[node1][node2]&gt;0)\r\n\r\n\t         changeweight(x, y);\r\n\r\n\t   }\r\n\r\n\t   else if (movestart) {\r\n\t      if (nodehit(x, y, NODESIZE))\r\n\r\n\t         startgraph=hitnode;\r\n\r\n\t      colornode[startgraph]=Color.blue;\r\n\r\n\t      movestart=false;\r\n\r\n\t   }\r\n\r\n\t   repaint();\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n    }\r\n\r\n\r\n\r\n    public boolean nodehit(int x, int y, int dist) {\r\n\tfor (int i=0; i&lt;numnodes; i++)\r\n\r\n\t  if ( (x-node[i].x)*(x-node[i].x) + \r\n\r\n\t\t\t\t(y-node[i].y)*(y-node[i].y) &lt; dist*dist ) {\r\n\r\n\t     hitnode = i;\r\n\r\n\t     return true;\r\n\r\n\t  }\r\n\r\n\treturn false;\r\n\r\n    }\r\n\r\n\r\n\r\n    public boolean arrowhit(int x, int y, int dist) {\r\n\tfor (int i=0; i&lt;numnodes; i++)\r\n\r\n\t  for (int j=0; j&lt;numnodes; j++) {\r\n\r\n\t     if ( ( weight[i][j]&gt;0 ) && \r\n\r\n\t\t\t(Math.pow(x-arrow[i][j].x, 2) + \r\n\r\n\t\t\t Math.pow(y-arrow[i][j].y, 2) &lt; Math.pow(dist, 2) ) ) {\r\n\r\n\t        node1 = i;\r\n\r\n\t        node2 = j;\r\n\r\n\t        return true;\r\n\r\n\t     }\r\n\r\n\t  }\r\n\r\n\treturn false;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void nodedelete() {\r\n\tnode[node1]=new Point(-100, -100);\r\n\r\n\tfor (int j=0;j&lt;numnodes;j++) {\r\n\r\n\t   weight[node1][j]=0;\r\n\r\n\t   weight[j][node1]=0;\r\n\r\n\t}\r\n\r\n\temptyspots++;\r\n\r\n    }\r\n\r\n\r\n\r\n    public void changeweight(int x, int y) {\r\n\tint diff_x = (int)(20*dir_x[node1][node2]);\r\n\r\n\tint diff_y = (int)(20*dir_y[node1][node2]);\r\n\tboolean follow_x=false;\r\n\r\n\t   if (Math.abs(endp[node1][node2].x-startp[node1][node2].x) &gt; Math.abs(endp[node1][node2].y-startp[node1][node2].y) ) {\r\n\r\n\t   follow_x = true;\r\n\r\n\t}\r\n\tif (follow_x) {\r\n\r\n\t    int hbound = Math.max(startp[node1][node2].x,endp[node1][node2].x)-Math.abs(diff_x);\r\n\r\n\t    int lbound = Math.min(startp[node1][node2].x,endp[node1][node2].x)+Math.abs(diff_x);\r\n\r\n\t    if (x&lt;lbound) { arrow[node1][node2].x=lbound; }\r\n\r\n\t    else if (x&gt;hbound) { arrow[node1][node2].x=hbound; }\r\n\r\n\t    else arrow[node1][node2].x=x;\r\n\r\n\r\n\r\n\t    arrow[node1][node2].y=(arrow[node1][node2].x-startp[node1][node2].x)*(endp[node1][node2].y-startp[node1][node2].y)/(endp[node1][node2].x-startp[node1][node2].x)+startp[node1][node2].y;\r\n\t    \r\n\t    weight[node1][node2]=Math.abs(arrow[node1][node2].x-startp[node1][node2].x-diff_x)*100/(hbound-lbound);\r\n\r\n\t}\r\n\telse {\r\n\r\n\t    int hbound = Math.max(startp[node1][node2].y,endp[node1][node2].y)-Math.abs(diff_y);\r\n\r\n\t    int lbound = Math.min(startp[node1][node2].y,endp[node1][node2].y)+Math.abs(diff_y);\r\n\r\n\r\n\r\n\t    if (y&lt;lbound) { arrow[node1][node2].y=lbound; }\r\n\r\n\t    else if (y&gt;hbound) { arrow[node1][node2].y=hbound; }\r\n\r\n\t    else arrow[node1][node2].y=y;\r\n\r\n\t    arrow[node1][node2].x=(arrow[node1][node2].y-startp[node1][node2].y)*(endp[node1][node2].x-startp[node1][node2].x)/(endp[node1][node2].y-startp[node1][node2].y)+startp[node1][node2].x;\r\n\r\n\r\n        weight[node1][node2]=Math.abs(arrow[node1][node2].y-startp[node1][node2].y-diff_y)*100/(hbound-lbound);\r\n\r\n\t}\r\n\r\n    }\r\n\r\n\r\n\r\n    public void arrowupdate(int p1, int p2, int w) {\r\n\t\r\n\tint dx, dy;\r\n\r\n\tfloat l;\r\n\r\n\tweight[p1][p2]=w;\r\n\t\r\n\tdx = node[p2].x-node[p1].x;\r\n\r\n\tdy = node[p2].y-node[p1].y;\r\n\t\r\n\tl = (float)( Math.sqrt((float)(dx*dx + dy*dy)));\r\n\r\n\tdir_x[p1][p2]=dx/l;\r\n\r\n\tdir_y[p1][p2]=dy/l;\r\n\t\r\n\tif (weight[p2][p1]&gt;0) {\r\n\r\n\t   startp[p1][p2] = new Point((int)(node[p1].x-5*dir_y[p1][p2]),(int)(node[p1].y+5*dir_x[p1][p2]));\r\n\r\n\t   endp[p1][p2] = new Point((int)(node[p2].x-5*dir_y[p1][p2]),(int)(node[p2].y+5*dir_x[p1][p2]));\r\n\r\n\t}\r\n\r\n\telse {\r\n\r\n\t   startp[p1][p2] = new Point(node[p1].x, node[p1].y);\r\n\r\n\t   endp[p1][p2] = new Point(node[p2].x, node[p2].y);\r\n\r\n\t}\r\n\tint diff_x = (int)(Math.abs(20*dir_x[p1][p2]));\r\n\r\n\tint diff_y = (int)(Math.abs(20*dir_y[p1][p2]));\r\n\t\r\n\tif (startp[p1][p2].x&gt;endp[p1][p2].x) {\r\n\r\n\tarrow[p1][p2] = new Point(endp[p1][p2].x + diff_x+(Math.abs(endp[p1][p2].x-startp[p1][p2].x) - 2*diff_x )*(100-w)/100 , 0);\r\n\r\n\t}\r\n\r\n\telse {\r\n\r\n\t   arrow[p1][p2] = new Point(startp[p1][p2].x + diff_x + (Math.abs(endp[p1][p2].x-startp[p1][p2].x) - 2*diff_x )* w/100, 0);\r\n\r\n\t}\r\n\r\n\tif (startp[p1][p2].y&gt;endp[p1][p2].y) {\r\n\r\n\t   arrow[p1][p2].y=endp[p1][p2].y + diff_y + (Math.abs(endp[p1][p2].y-startp[p1][p2].y) - 2*diff_y )*(100-w)/100;\r\n\r\n\t}\r\n\r\n\telse {\r\n\r\n\t   arrow[p1][p2].y=startp[p1][p2].y + diff_y + (Math.abs(endp[p1][p2].y-startp[p1][p2].y) - 2*diff_y )*w/100;\r\n\r\n\t}\r\n\r\n    }\r\n\r\n\r\n    public String intToString(int i) {\r\n\r\n\tchar c=(char)((int)'a'+i);\r\n\r\n\treturn &quot;&quot;+c;\r\n\r\n    }\r\n\r\n\r\n\r\n    public final synchronized void update(Graphics g) {\r\n\t\r\n\tDimension d=size();\r\n\r\n\tif ((offScreenImage == null) || (d.width != offScreenSize.width) || (d.height != offScreenSize.height)) {\r\n\r\n\t    offScreenImage = createImage(d.width, d.height);\r\n\r\n\t    offScreenSize = d;\r\n\r\n\t    offScreenGraphics = offScreenImage.getGraphics();\r\n\r\n\t}\r\n\r\n\toffScreenGraphics.setColor(Color.white);\r\n\r\n\toffScreenGraphics.fillRect(0, 0, d.width, d.height);\r\n\r\n\tpaint(offScreenGraphics);\r\n\r\n\tg.drawImage(offScreenImage, 0, 0, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void drawarrow(Graphics g, int i, int j) {\r\n\r\n\tint x1, x2, x3, y1, y2, y3;\r\n\r\n\tx1= (int)(arrow[i][j].x - 3*dir_x[i][j] + 6*dir_y[i][j]);\r\n\r\n\tx2= (int)(arrow[i][j].x - 3*dir_x[i][j] - 6*dir_y[i][j]);\r\n\r\n\tx3= (int)(arrow[i][j].x + 6*dir_x[i][j]);\r\n\r\n\r\n\r\n\ty1= (int)(arrow[i][j].y - 3*dir_y[i][j] - 6*dir_x[i][j]);\r\n\r\n\ty2= (int)(arrow[i][j].y - 3*dir_y[i][j] + 6*dir_x[i][j]);\r\n\r\n\ty3= (int)(arrow[i][j].y + 6*dir_y[i][j]);\r\n\r\n\r\n\r\n\tint arrowhead_x[] = { x1, x2, x3, x1 };\r\n\r\n\tint arrowhead_y[] = { y1, y2, y3, y1 };\r\n\r\n\tif (algedge[i][j]) g.setColor(Color.orange);\r\n\r\n\tg.drawLine(startp[i][j].x, startp[i][j].y, endp[i][j].x, endp[i][j].y);\r\n\r\n\tg.fillPolygon(arrowhead_x, arrowhead_y, 4);\r\n\r\n\tint dx = (int)(Math.abs(7*dir_y[i][j]));\r\n\r\n\tint dy = (int)(Math.abs(7*dir_x[i][j]));\r\n\r\n\tString str = new String(&quot;&quot; + weight[i][j]);\r\n\r\n\tg.setColor(Color.black);\r\n\r\n\tif ((startp[i][j].x&gt;endp[i][j].x) && (startp[i][j].y&gt;=endp[i][j].y)) \r\n\t\tg.drawString( str, arrow[i][j].x + dx, arrow[i][j].y - dy);\r\n\r\n\tif ((startp[i][j].x&gt;=endp[i][j].x) && (startp[i][j].y&lt;endp[i][j].y)) \r\n\t\tg.drawString( str, arrow[i][j].x - fmetrics.stringWidth(str) - dx , arrow[i][j].y - dy);\r\n\r\n\tif ((startp[i][j].x&lt;endp[i][j].x) && (startp[i][j].y&lt;=endp[i][j].y))\r\n\r\n\t  g.drawString( str, arrow[i][j].x - fmetrics.stringWidth(str),arrow[i][j].y + fmetrics.getHeight());\r\n\r\n\tif ((startp[i][j].x&lt;=endp[i][j].x) && (startp[i][j].y&gt;endp[i][j].y))\r\n      g.drawString( str, arrow[i][j].x + dx,arrow[i][j].y + fmetrics.getHeight() );\r\n\r\n    }\r\n    \r\n public class BellmanFord\r\n{\r\n  private static class Vertex  \r\n  {\r\n    String label;              \r\n    int pred;                  \r\n    double d;                  \r\n    public Vertex(String label)\r\n    {\r\n      this.label = label;      \r\n      pred = -1;            \r\n    }\r\n  }\r\n\r\n  private static class Arc   \r\n  {                           \r\n    int vertex;                 \r\n    double weight;             \r\n    public Arc(int v, double w) \r\n    {\r\n      vertex = v;\r\n      weight = w;\r\n    }\r\n  }\r\n\r\n  private static Vertex[] vertices;  \r\n  private static Arc[][] adjList;   \r\n  private static int source;        \r\n\r\n  public static void main(String[] args)\r\n  {\r\n    readGraph(args);                \r\n    printAdjList(&quot;Adjacency list of G&quot;, adjList);\r\n\r\n    if (bf(source))                 \r\n      printShortestPaths(source);\r\n    else\r\n      System.out.println(&quot;G contains a negative weight loop&quot;);\r\n  }\r\n\r\n  public static boolean bf(int s)   \r\n  {\r\n    initSingleSource(s);\r\n\r\n    for (int i=1; i&lt;vertices.length; i++)\r\n      for (int u=0; u&lt;adjList.length; u++)\r\n        for (int v=0; v&lt;adjList[u].length; v++)\r\n          relax(u, adjList[u][v].vertex, adjList[u][v].weight);\r\n\r\n    for (int u=0; u&lt;adjList.length; u++)\r\n      for (int v=0; v&lt;adjList[u].length; v++)\r\n        if (vertices[adjList[u][v].vertex].d &gt; \r\n            vertices[u].d + adjList[u][v].weight)\r\n          return(false);\r\n\r\n    return(true);\r\n  }\r\n\r\n  public static void initSingleSource(int s)\r\n  {\r\n    for (int v=0; v&lt;vertices.length; v++)\r\n    {\r\n      vertices[v].d = Double.MAX_VALUE;    \r\n      vertices[v].pred = -1;               \r\n    }\r\n    vertices[s].d = 0;\r\n  }\r\n\r\n  public static void relax(int u, int v, double w)\r\n  {\r\n    if (vertices[v].d &gt; vertices[u].d + w)\r\n    {\r\n      vertices[v].d = vertices[u].d + w;\r\n      vertices[v].pred = u;\r\n    }\r\n  }\r\n\r\n  public static void printShortestPaths(int s)\r\n  {\r\n    System.out.println(&quot;\\nShortest paths from &quot; + vertices[s].label + &quot;:&quot;);\r\n    for (int v=0; v&lt;vertices.length; v++)\r\n    {\r\n      Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\r\n      stack.push(new Integer(v)); \r\n      for (int u=vertices[v].pred; u &gt;= 0; u=vertices[u].pred)\r\n        stack.push(new Integer(u));\r\n\r\n      int i = stack.pop().intValue();             \r\n      System.out.print(vertices[i].label);         \r\n      int length = 0;                          \r\n      if (v == s) System.out.print(&quot; -&gt; &quot; + vertices[i].label);\r\n      else                                          \r\n      while (! stack.isEmpty())                    \r\n      {\r\n        int j = stack.pop().intValue();            \r\n        System.out.print(&quot; -&gt; &quot; +vertices[j].label);\r\n        int k = 0;                                  \r\n        for ( ; adjList[i][k].vertex != j; k++);   \r\n        length += adjList[i][k].weight;            \r\n        i = j;\r\n      }\r\n      System.out.println(&quot; length=&quot; + length);  \r\n    }\r\n  }\r\n\r\n \r\n  public static void printAdjList(String s, Arc[][] adj)\r\n  {\r\n    System.out.println(s);\r\n    for (int i=0; i&lt;adj.length; i++)\r\n    {\r\n      System.out.print(vertices[i].label + &quot;: &quot;);\r\n      for (int j=0; j&lt;adj[i].length; j++)\r\n        System.out.print(vertices[adj[i][j].vertex].label + &quot;/&quot; +\r\n          adj[i][j].weight + &quot; &quot;);\r\n      System.out.println();\r\n    }\r\n  }\r\n\r\n \r\n  public static void readGraph(String[] args) \r\n  {\r\n    if (args.length == 0)\r\n    {\r\n      System.out.println(&quot;No source node specified&quot;);\r\n      System.exit(0);\r\n    }\r\n    Scanner inFile = new Scanner(System.in);\r\n\r\n    HashMap&lt;String, Integer&gt; nodeMap =\r\n       new HashMap&lt;String, Integer&gt;(); \r\n    ArrayList&lt;Vertex&gt; nodeList =\r\n       new ArrayList&lt;Vertex&gt;();      \r\n    String input = &quot;&quot;;                \r\n    int index = 0;\r\n    String s = &quot;&quot;;\r\n    while (inFile.hasNextLine())  \r\n    {\r\n      s = inFile.nextLine();       \r\n      if (s.length() &gt; 0 && s.charAt(0) != '#') \r\n      {\r\n        StringTokenizer sTk = new StringTokenizer(s);\r\n        String label = sTk.nextToken();\r\n        if (! nodeMap.containsKey(label)) \r\n        {\r\n          Vertex v = new Vertex(label);  \r\n          nodeMap.put(label, new Integer(index));\r\n          nodeList.add(v);                       \r\n          index++;\r\n          input = input + &quot;#&quot; + s;     \r\n        }\r\n        else                         \r\n        {\r\n          System.out.println(&quot;Multiple declaration of vertex: &quot; + label);\r\n          System.exit(0);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (nodeMap.containsKey(args[0]))\r\n      source = nodeMap.get(args[0]).intValue();\r\n    else\r\n    {\r\n      System.out.println(&quot;Non-existing source node &quot; + args[0]);\r\n      System.exit(0);\r\n    }\r\n\r\n  \r\n    vertices = (Vertex[]) nodeList.toArray(new Vertex[nodeList.size()]);\r\n\r\n  \r\n    adjList = new Arc[vertices.length][]; \r\n    StringTokenizer sTk = new StringTokenizer(input, &quot;#&quot;);\r\n    for (int i=0; i&lt;vertices.length; i++)\r\n    {\r\n      StringTokenizer sTk1 = new StringTokenizer(sTk.nextToken());\r\n      adjList[i] = new Arc[(sTk1.countTokens()-1)/2];\r\n      s = sTk1.nextToken();\r\n      for (int j=0; j&lt;adjList[i].length; j++)\r\n      {\r\n        s = sTk1.nextToken();\r\n        double weight = 0;\r\n        try\r\n        {\r\n          weight = Double.parseDouble(sTk1.nextToken()); \r\n        }\r\n        catch(NumberFormatException nfe)\r\n        {\r\n          System.out.println(&quot;Wrong label/weight combination in the &quot; +\r\n               &quot;adjacency list of &quot; + vertices[i].label);\r\n          System.exit(0);\r\n        }\r\n        catch(NoSuchElementException nfe)\r\n        {\r\n          System.out.println(&quot;Wrong adjacency list for node &quot; + \r\n                             vertices[i].label);\r\n          System.exit(0);\r\n        }\r\n\r\n        if (nodeMap.containsKey(s))\r\n        {\r\n          int ind = nodeMap.get(s).intValue();\r\n          adjList[i][j] = new Arc(ind, weight);\r\n        }\r\n        else\r\n        {\r\n          System.out.println(&quot;Undeclared vertex: &quot; + s);\r\n          System.exit(0);\r\n        } \r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "PostedDate": "2010-06-06T18:28:04.143-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]