[
  {
    "Id": "203905",
    "ThreadId": "60227",
    "Html": "<p>Are there any plans to include Graph Comparers, especially equality comparers,&nbsp;in QG?</p>\r\n<p>For example given a Set of Graphs, we may need to check if a candidate exists in it. This can be done using a HasSet and a CustomEqualityComparer. However, having something in-built would be useful for graph mining applications. This would be on the lines on the StringEqualityComparer and StringComparer types in .Net</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-06-21T20:48:59.427-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "203908",
    "ThreadId": "60227",
    "Html": "<p>QuickGraph does not have graph isomorphism algorithms so that feature is not really easy to implement as is. What kind of equality are you thinking about?</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-06-21T21:02:12.673-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "204278",
    "ThreadId": "60227",
    "Html": "<p>Here is my definition</p>\r\n<ul>\r\n<li>Two nodes are equal when they have same <em>label</em></li>\r\n<li>Two edges are equal when the Source nodes are equal and Target nodes are equal</li>\r\n<li>Two graphs are equal, if they have the same nodes and same edges</li>\r\n</ul>\r\n<p>Suppose G1&nbsp;has V={1,2}, E={(1,2)} and G2 has V={1,2,3}, E={(1,2)}. Then G1 !=G2. However, G1==G1.</p>\r\n<p>And here's my sample implementation.</p>\r\n<p>&nbsp;&nbsp;&nbsp; public class UndirectedGraphEqualityComparer : IEqualityComparer&lt;UndirectedGraph&lt;int, Edge&lt;int&gt;&gt;&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region IEqualityComparer&lt;UndirectedGraph&lt;int,Edge&lt;int&gt;&gt;&gt; Members<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool Equals(UndirectedGraph&lt;int, Edge&lt;int&gt;&gt; x, UndirectedGraph&lt;int, Edge&lt;int&gt;&gt; y)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x.EdgeCount != y.EdgeCount)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (x.VertexCount != y.VertexCount)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in x.Vertices)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!y.Vertices.Contains(item))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in x.Edges)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!y.Edges.Contains(item, new EdgeEqualityComparer()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int GetHashCode(UndirectedGraph&lt;int, Edge&lt;int&gt;&gt; obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int edgeHashCode = obj.EdgeCount.GetHashCode() ^ obj.VertexCount.GetHashCode();</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in obj.Edges)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeHashCode ^= item.Source.GetHashCode() ^ item.Target.GetHashCode();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in obj.Vertices)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edgeHashCode ^= item.GetHashCode();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return edgeHashCode;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<br>&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp; public class EdgeEqualityComparer : IEqualityComparer&lt;Edge&lt;int&gt;&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region IEqualityComparer&lt;Edge&lt;int&gt;&gt; Members</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool Equals(Edge&lt;int&gt; x, Edge&lt;int&gt; y)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x.Target.Equals(y.Target) &amp;&amp; x.Source.Equals(y.Source);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int GetHashCode(Edge&lt;int&gt; obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return obj.Target.GetHashCode() ^ obj.Source.GetHashCode();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;</p>",
    "PostedDate": "2009-06-22T18:10:42.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "204362",
    "ThreadId": "60227",
    "Html": "<p>The problem with your comparers is that you assume the edges are sorted in the same order in each graph. The problem relies on your GetHashCode() implementation.</p>\r\n<p>ps: don't write &quot;y.Edges.Contains&quot;, this is very inefficient. This is a really Enumerable.Contains(y.Edges), so each time you walk the entire edge list. Use 'y.ContainsEdge' instead which should be more efficent.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-06-22T23:53:18.073-07:00",
    "UserRole": "Owner",
    "MarkedAsAnswerDate": null
  }
]