<div class="wikidoc"><h4>Observers Concepts</h4>
Algorithms do not serialize any interesting data. They publish a set of standard events that an observer can listen to gather the data (algorithms and observers in QuickGraph implement the <a href="https://quickgraph.codeplex.com/wikipage?title=Observer%20Pattern&referringTitle=Observer%20Concepts">Observer Pattern</a>). For example, one can attach an observer that records the vertex predecessors to algorithms that compute the shortest path.<br />
<ul><li><span class="codeInline">VertexPredecessorRecorderObserver</span>, creates a dictionary that links vertices to their parent edge,</li>
<li><span class="codeInline">EdgePredecessorRecorderObserver</span>, create a dictionary that links vertices to their parent edge,</li>
<li><span class="codeInline">VertexDistanceRecorderObserver</span>, stores the distance of vertices from the root vertex,</li>
<li><span class="codeInline">VertexTimeStamperObserver</span>, stores the time instant where a vertex processing start and finishes</li></ul>
 
<h5>Using observers</h5>
Observer instance are to be &#39;attached&#39; to algorithms during the computation. All observer implement an <span class="codeInline">Attach</span> method that returns a disposable instance. When disposing, this instance &#39;detached&#39; the observer from the algorithm events.<br /><br /><pre>
    IVertexListGraph&lt;TVertex,TEdge&gt; g = ...; // some graph instance
    var dfs = new DepthFirstSearchAlgorithm&lt;TVertex,TEdge&gt;(g);
    var predecessorRecorder = new VertexPredecessorRecorderObserver&lt;TVertex,TEdge&gt;();

    using(predecessorRecorder.Attach(dfs)) // listen to dfs events, then unhook
        dfs.Compute();   
</pre><br /></div><div class="ClearBoth"></div>