<div class="wikidoc"><h3>Dijkstra Shortest Path Distance Example</h3>
<h4>Dijkstra extension methods</h4>
The AlgorithmExtensions class contains several helper methods to execute the algorithm on a given graph.<br /><pre>
using QuickGraph;
using QuickGraph.Algorithms;

IVertexAndEdgeListGraph&lt;TVertex, TEdge&gt; graph = ...;
Func&lt;TEdge, double&gt; edgeCost = e =&gt; 1; // constant cost
TVertex root = ...;

// compute shortest paths
TryFunc&lt;TVertex, TEdge&gt; tryGetPaths = graph.ShortestPathDijkstra(edgeCost, root);

// query path for given vertices
TVertex target = ...;
IEnumerable&lt;TEdge&gt; path;
if (tryGetPaths(target, out path))
    foreach(var edge in path)
        Console.WriteLine(edge);
</pre><br />
<h4>Advanced use</h4>This example sets up a Dijkstra shortest path algorithm and computes the distance of the vertices in the graph.<br /><pre>
Func&lt;TEdge, double&gt; edgeCost = e =&gt; 1; // constant cost
// We want to use Dijkstra on this graph
var dijkstra = new DijkstraShortestPathAlgorithm&lt;TEdge, TEdge&gt;(graph, edgeCost);
</pre>
<h4>Using a predecessor recorder to build the shortest path tree</h4>Algorithms raise a number of events that <a href="https://quickgraph.codeplex.com/wikipage?title=Observer%20Concepts&referringTitle=Dijkstra%20Shortest%20Distance%20Example">observes</a> can leverage to build solutions. For example, attaching a predecessor recorder<br />to the Dijkstra algorithm will let us build a predecessor tree. This tree is later used to build shortest paths.<br /><pre>
// Attach a Vertex Predecessor Recorder Observer to give us the paths
var predecessors = new VertexPredecessorRecorderObserver&lt;TVertex, TEdge&gt;();
using (predecessors.Attach(dijkstra))
    // Run the algorithm with A set to be the source
    dijkstra.Compute(&quot;A&quot;);
</pre><br />The <span class="codeInline">predecessors</span> instance now contains a dictionary of distance from each vertex to the source:<br /><pre>
foreach (var v in graph.Vertices) {
    double distance = 0;
    TVertex vertex = v;
    TEdge predecessor;
     while (predecessors.VertexPredecessors.TryGetValue(vertex, out predecessor)) {
          distance += edgeCost[predecessor];
          vertex = predecessor.Source;
     }
     Console.WriteLine(&quot;A -&gt; {0}: {1}&quot;, v, distance);
}
</pre>
<h5>Using a dictionary for edge costs</h5>Because the algorithm take a delegate as the edge cost, one cannot simply pass a dictionary. QuickGraph provides a helper method, GetIndexer, to make the conversion:<br /><pre>
Dictionary&lt;TEdge, double&gt; edgeCostDictionary = ...
Func&lt;TEdge,double&gt; edgeCost = AlgorithmExtensions.GetIndexer(edgeCostDictionary);
...
</pre></div><div class="ClearBoth"></div>