using System;
using System.Collections.Generic;
using QuickGraph;
using QuickGraph.Algorithms.RankedShortestPath;

namespace ShipConRunner
{
	class Edge : IEdge<string>
	{
		string _from;
		string _to;

		public Edge(string f, string t)
		{
			_from = f;
			_to = t;
		}

		public string Source
		{
			get { return _from; }
		}

		public string Target
		{
			get { return _to; }
		}

		public override string ToString()
		{
			return _from + _to;
		}


		public bool Equals(Edge e) { return _from == e._from && _to == e._to; }

		public override bool Equals(object o)
		{
			if (o is Edge)
			{
				Edge other = o as Edge;
				return Equals(other);
			}
			return false;
		}

		public static double EdgeWeight(Edge e) { return 1.0; }
	}


	class StringGraph : IBidirectionalGraph<string, Edge>
	{
		Dictionary<string, List<string>> _network = new Dictionary<string,List<string>>();

		public StringGraph()
		{

		}


		public void MakeConnection(string root, string other)
		{
			List<string> adj = _network[root];
			if (!adj.Contains(other))
			{
				adj.Add(other);
			}
		}


		public void AddConnection(string from, string to)
		{
			EnsureVertexExists(from);
			EnsureVertexExists(to);
			MakeConnection(from, to);
			MakeConnection(to, from);
		}

		private void EnsureVertexExists(string to)
		{
			if (!_network.ContainsKey(to))
			{
				List<string> adjList = new List<string>();
				_network.Add(to, adjList);
			}
		}


		public int Degree(string v)
		{
			return InDegree(v) + OutDegree(v);
		}


		public int InDegree(string v)
		{
			return _network[v].Count;
		}



		public IEnumerable<Edge> InEdges(string v)
		{
			List<Edge> rtn = new List<Edge>();
			foreach (string n in _network[v])
			{
				Edge edge = new Edge(n, v);
				rtn.Add(edge);
			}
			return rtn;
		}


		public Edge OutEdge(string v, int index)
		{
			throw new NotImplementedException();
		}

		public IEnumerable<Edge> OutEdges(string v)
		{
			List<Edge> rtn = new List<Edge>();
			foreach (string n in _network[v])
			{
				Edge edge = new Edge(v, n);
				rtn.Add(edge);
			}
			return rtn;
		}


		public IEnumerable<string> Vertices
		{
			get { return _network.Keys; }
		}


		public Edge InEdge(string v, int index)
		{
			throw new NotImplementedException();
		}


		public bool IsInEdgesEmpty(string v)
		{
			throw new NotImplementedException();
		}


		public bool TryGetInEdges(string v, out IEnumerable<Edge> edges)
		{
			throw new NotImplementedException();
		}


		public bool ContainsEdge(string source, string target)
		{
			throw new NotImplementedException();
		}


		public bool TryGetEdge(string source, string target, out Edge edge)
		{
			throw new NotImplementedException();
		}


		public bool TryGetEdges(string source, string target, out IEnumerable<Edge> edges)
		{
			throw new NotImplementedException();
		}


		public bool IsOutEdgesEmpty(string v)
		{
			throw new NotImplementedException();
		}

		public int OutDegree(string v)
		{
			throw new NotImplementedException();
		}


		public bool TryGetOutEdges(string v, out IEnumerable<Edge> edges)
		{
			throw new NotImplementedException();
		}


		public bool AllowParallelEdges
		{
			get { throw new NotImplementedException(); }
		}


		public bool IsDirected
		{
			get { throw new NotImplementedException(); }
		}


		public bool ContainsVertex(string vertex)
		{
			throw new NotImplementedException();
		}


		public bool IsVerticesEmpty
		{
			get { throw new NotImplementedException(); }
		}


		public int VertexCount
		{
			get { return _network.Keys.Count; }
		}


		public bool ContainsEdge(Edge edge)
		{
			throw new NotImplementedException();
		}


		public int EdgeCount
		{
			get { throw new NotImplementedException(); }
		}


		public IEnumerable<Edge> Edges
		{
			get { throw new NotImplementedException(); }
		}


		public bool IsEdgesEmpty
		{
			get { throw new NotImplementedException(); }
		}
	}

	class Tester
	{
		public static void Main()
		{
			StringGraph graph = new StringGraph();
			graph.AddConnection("A", "B");
			graph.AddConnection("A", "C");
			graph.AddConnection("B", "C");

			HoffmanPavleyRankedShortestPathAlgorithm<string, Edge> algo =
				new HoffmanPavleyRankedShortestPathAlgorithm<string, Edge>(graph, Edge.EdgeWeight);

			algo.ShortestPathCount = 5;
	
			algo.Compute("A", "B");
		}
	}
}
