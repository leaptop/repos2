{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": null,
    "CommentCount": 0,
    "Custom": null,
    "Description": "In my graphs, I generally have at least two completely disconnected subgraphs or components. These components may be of 1 or N vertices. I can easily detect orphans, but not components.\n\nOrphans are easy: \n\nmyGraph.Vertices.Where(v => myGraph.InDegree(v) == 0)\n\nI have no idea how to get the disconnected components. Ideally, I'd like to return an IEnumerable<BidirectionalGraph<T>> from myGraph which is BidirectionalGraph<T>.",
    "LastUpdatedDate": "2014-10-29T15:07:31.703-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Unassigned",
      "Severity": 0,
      "Id": 0
    },
    "ProjectName": "quickgraph",
    "ReportedDate": "2014-09-29T06:04:04.11-07:00",
    "Status": {
      "Name": "Proposed",
      "Id": 1
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Finding Disconnected Subgraphs or Components",
    "Type": {
      "Name": "Unassigned",
      "Id": 5
    },
    "VoteCount": 2,
    "Id": 25751
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "I would be very interested by this feature, and I did not find how to do it yet.\r\n\r\nIt seems like the function does part of the job:\nFunc<KeyValuePair<int, IDictionary<DataVertex, int>>> components = AlgorithmExtensions.IncrementalConnectedComponents(graph);\nvar current = components();\r\n\r\nBy examining current, you see vertices that share the same branches (see value index).\nBut it does not give directly the list of sub-graphs: IEnumerable<BidirectionalGraph<T>>\r\n\r\n\nMaybe the weaklyConnectedComponents, and condensateWeaklyConnected extensions can do the job.\nI haven't been able to implement any of them.\r\n\r\nThe following code casts an error.\nvar weaklyCondensated= g.CondensateWeaklyConnected<Vertex,Edge,GraphType>(); \r\n\r\nI would be very interested to have a solution for this.\nThanks a lot",
      "PostedDate": "2014-10-29T14:14:18.6-07:00",
      "Id": -2147483648
    },
    {
      "Message": "Actually for those interested there is a solution given in another post.\n-> Solution given in the comments to solve the bug in \"CondensationGraphAlgorithm\".\r\n\r\nOne it is solved (I tried by adding a CondensationGraphAlgorithm2 in a new class, with the corrected code), you can get what you want like this (it is basically the code of \"g.CondensateWeaklyConnected\" actually!)\r\n\r\n\nvar condensator = new QuickGraph.Algorithms.Condensation.CondensationGraphAlgorithm2<DataVertex, DataEdge, CalculationEngineGraph>(this.CalculationEngineGraph);\n            condensator.StronglyConnected = false;\n            condensator.Compute();  // Throws KeyNotFoundException if edgeless vertex is added\n            var condensed = condensator.CondensedGraph;\r\n\r\nIt should be simple to correct the code. I don't know if only the owner of the project can change it.\n",
      "PostedDate": "2014-10-29T15:07:31.703-07:00",
      "Id": -2147483648
    }
  ]
}