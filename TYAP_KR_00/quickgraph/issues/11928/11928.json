{
  "WorkItem": {
    "AffectedComponent": {
      "Name": "",
      "DisplayName": ""
    },
    "ClosedComment": "",
    "ClosedDate": "2008-12-11T22:04:38.967-08:00",
    "CommentCount": 0,
    "Custom": null,
    "Description": "It would be nice to see the search algorithms (DFS, BFS, etc...) support a user-defined heuristic function for selecting the next node(s) to visit.  Currently, the DFS and BFS algorithms use the implicit Vertex.OutEdges ordering.\nÂ \nThe heuristic function prototype could be Func<TVertex, IEnumerable<TEdge>>, or something more appropriate.  In this case TVertex is the vertex type and would be the vertex from which the candidate traversals are selected.  IEnumerable<TEdge> is the resulting list of edges.",
    "LastUpdatedDate": "2013-05-16T04:59:25.003-07:00",
    "PlannedForRelease": "",
    "ReleaseVisibleToPublic": false,
    "Priority": {
      "Name": "Low",
      "Severity": 50,
      "Id": 1
    },
    "ProjectName": "quickgraph",
    "ReportedDate": "2008-12-07T19:48:28.667-08:00",
    "Status": {
      "Name": "Closed",
      "Id": 4
    },
    "ReasonClosed": {
      "Name": "Unassigned"
    },
    "Summary": "Search Algorithms with Heuristics",
    "Type": {
      "Name": "Issue",
      "Id": 3
    },
    "VoteCount": 1,
    "Id": 11928
  },
  "FileAttachments": [],
  "Comments": [
    {
      "Message": "Would you something like Func<TVertex, IEnumerable<TEdge>, IEnumerable<TEdge>> that receives the out-edges and has the opportunity to reorder it?",
      "PostedDate": "2008-12-08T23:23:56.2-08:00",
      "Id": -2147483648
    },
    {
      "Message": "That will work very well.\r\n\r\nOn a side note, is there a way to refine this interface so that the user can't return an IEnumerable<TEdge> that references edges in another graph?  I suppose that the algorithm could check for edge membership in the graph, but it sounds like that will add too much overhead.",
      "PostedDate": "2008-12-09T18:05:17.713-08:00",
      "Id": -2147483648
    },
    {
      "Message": "That would be an overkill. The risk of enabling such functionality is that people might just return random edges and break the algorithms.\r\n\r\nHave you thought about using the FilteredGraphxxxx where you can define 'views' over graphs?",
      "PostedDate": "2008-12-10T07:19:26.093-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Wouldn't this  Func<TVertex, IEnumerable<TEdge>, IEnumerable<TEdge>> \r\nalso allow breakage?  User could return a shorter list...\r\n\r\nHow about a Sort Func that quickgraph would apply to the outEdges before iterating them?\r\n\r\n",
      "PostedDate": "2008-12-11T10:06:48.463-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Yes, the risk of giving to much flexibility is that it is going to break the invariants of the algorithm. Sorting the OutEdges sounds like a good midle ground.",
      "PostedDate": "2008-12-11T20:45:43.467-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Resolved with changeset 28164.",
      "PostedDate": "2008-12-11T22:04:38.967-08:00",
      "Id": -2147483648
    },
    {
      "Message": "Sorting is a great idea.\r\n\r\nRegarding the FilteredGraph, it seems like it will work but I need to think about it a bit more.  I'm wondering if there is a case where the edge-selection predicate needs to be different for certain edges.",
      "PostedDate": "2008-12-15T09:59:41.81-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-02-21T17:44:53.47-08:00",
      "Id": -2147483648
    },
    {
      "Message": "",
      "PostedDate": "2013-05-16T04:59:25.003-07:00",
      "Id": -2147483648
    }
  ]
}