<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308859 (ru-RU, MWS); Windows/10.0.0 (Win64);"/>
  <meta name="reminder-order" content="04.02.2020 4:41"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2203"/>

<div>
<span><div><div>Лектор Мамойленко Сергей Николаевич</div><div><br/></div><div>04.02.2020 7 лаб на автомат вовремя, курсач, экзамен, все задания в эиосе. Сдавать всё вовремя. Можно напарника из другой группы.</div><div><br/></div><div>22.02.2020 лекция: физический уровень. Линия передачи данных. DCE data circle environment DTE data terminal environment. Модем - модуляция/демодуляция. <span style="font-style: italic; font-weight: bold; text-decoration: underline;">Посещаемость в течение первых 30 минут отмечается. В том числе по СУББОТАМ</span>. Бод - бит/сек. Симплекс - передача только в одну сторону. Разделяемый Half-duplex источник и приемник по очереди меняются местами. Двунаправленный full-duplex - одновременно передается и туда и сюда. Два кусочка кварца невозможно на практике сделать с одной частотой (рано или поздно они разойдутся, даже если были запущены одновременно). Выход например в том чтобы поставить один кварцевый источник. Но это сложно. Проще синхронизировать оба устройства приема и передачи после каждой передачи кадра. Циклический избыточный код(CRC). </div><div><br/></div><div>18.02.2020 был на практике, но в эиос зашёл уже после половины пары. Система не разрешила нажимать кнопку. </div><div><br/></div><div>08.02.2020 мы как бы делаем сеть для предприятия. Потом предоставляем услуги по предоставлению телевидения, либо телефония.(курсач наверное). Курс абсолютно практический, но теория тоже будет. Все взаимодействие через эиос. Курсач сдается Крамаренко до 31 мая. Должна быть реально работающая сеть эмулированная. Отметка на практике: прочитать лекцию на эиосе и т.п.</div><div>Баллы: на автоматы: 3 120 баллов, на 4 6 лаб (без 7) и курсач на 4; просто так ставится 5 за сертификат от вендора.(элтекс, международные и т.п.).(там сделать надо в 5 раз больше, чем по программе). Везде д.б. пропускные баллы для автомата. <span style="font-style: italic; text-decoration: underline;">В эиосе можно общаться с преподавателем.</span></div><div>Предпосылки создания сетей эвм и телекоммуникаций. Свет самый быстрый.</div><div><br/></div><div>Придумали пакетную передачу данных. Пакетики могли быть для разных устройств. </div><div>Блок(пакет) называется кадром.</div><div><br/></div><div>Если нам предоставят OSI с внешним миром может не уметь общаться.</div><div><br/></div><div>Tcp подтверждает, гарантирует? доставку</div><div>Udp не подтверждает получение, только вещает</div><div><br/></div><div>Чтобы перейти в привилегированный режим ROUTER&gt;enable(без точки как в методичке)</div><div><br/></div><div>11.02.2020 был на практическом занятии. Сдал первую лабу, но система не зафиксировала меня.</div><div><br/></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(34, 34, 34); font-family: arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">DHCP — сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. Данный протокол работает по модели «клиент-сервер».</span></div><div><br/></div><div><span style="text-decoration: underline;">Сначала айпишники проставить, потом адрес сети.</span></div><div><br/></div><div><span style="text-decoration: underline;">Чтобы не было оверлапа надо указывать маску 255.255.255.0</span></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Как работает коммутатор ethernet:</span> алгоритм обратного обучения: принимая допустим на порт №3 кадр, видит в нём мак адрес как отправителя, так и получателя. Адрес отправителя естетсвенно приписывается порту №3 и в итоге хранится в таблице. Так будет продолжаться, пока коммутатор на запишет информацию обо всех компьютерах сети(подключенных к его портам). Коммутатор - это по сути прозрачный мост, с большим количеством портов, т.к. он не заметен для сетевых устройств и не требует настройки.</div><div> Допустим таблица заполнена. Получая кадры, он смотрит мак адреса своей таблицы и сравнивает их с адресом получаетля. Если находит совпадение, то шлёт кадр на порт с совпавшим мак адресом. Если пришедшего мак адреса нет в таблице, то кадр шлётся на все порты. Заголовок, хранящий мак адрес  -  это заголовок канального уровня. В классическом ethernet все компьютеры подключены к концентратору(разделяемой среде) это топология звезда (физическая) однако логическая топология - общая шина . Современный ethernet - тоже звезда, но логическая топология - полносвязная.</div><div><br/></div><div>Сервис - описывает какие функции реализует уровень(например уровень может организовывать гарантированную доставку данных от одного приложения к другому, или поиск маршрута в большой составной сети). </div><div>Интерфейс - набор примитивных операций, которые нижний уровень предоставляет верхнему. </div><div>Протокол - правила и соглашения, используемые для связи уровня N одного компьютера с уровнем N другого компьютера.(как уровень это делает)</div><div>Интерфейс: реальное общение внутри компьютера. Уровень N вызывает функции уровня N-1 . Например программист создаёт сокет и записывает в него данные.(как получить доступ к сервису уровня)</div><div>Пртокол: виртуальное общение между компьютерами. Реально соединяются только уровни, работающие с физической средой. Взаимодействие через заголовки протокола соответствующего уровня.</div><div><br/></div><div>Архитектура сети: Набор уровней и протоколов сети. Интерфейсы в архитектуру не входят, т.к. могут быть разными на разных программно-аппаратных платформах.</div><div>Стек протоколов: Иерархически организованный набор протоколов, достаточный для организации взаимодействия по сети. </div><div><br/></div><div>Модель ISO OSI включает 7 уровней, но не включает протоколы. Хорошая теоретическая проработка. На практике не используется.</div><div>Модель TCP/IP - фактический стандарт на основе популярного стека протоколов TCP/IP. Содержит 4 уровня. Протоколы TCP/IP широко используются на практике. Основа Интернет. </div><div><br/></div><div>Инкапсуляция - включение сообщения вышестоящего уровня в сообщение нижестоящего уровня. Сообщение: заголовок + данные + концевик. </div><div><br/></div><div>Например с 3-го уровня данные передаются на второй, при этом второй уровень понимает, что оно слишком большое для передачи по сети, поэтому разбивает его на две части, снабжая их заголовками. Дальше сообщения поступают на первый уровень, который добавляет свой  заголовок и(необязательно) концевик(может потребоваться, т.к. 1-й уровень работает со средой и там может понадобиться коцевик. Данные переданы на 1-й уровень узла получателя. Здесь заголовок и концевик 1-го уровня удаляются. На втором уровне, соответственно удаляются заголовки 2-го уровня, два сообщения объединяются в одно и передаётся на 3-й уровень. Всё это называется декомпозицией на уровни. Каждый уровень выполняет одну или несколько чётко определённых функций. Уровень предоставляет сервис верхнему уровню. </div><div><br/></div><div>Модель Open System Interconnection:</div><div>Задача <span style="font-style: italic; text-decoration: underline;">физ. уровня</span>: представить биты информации в виде сигналов, передаваемых по среде. Не вникает в смысл передаваемой информации. <span style="font-style: italic; text-decoration: underline;">Единица: бит. Устройство: концентратор</span></div><div><span style="font-weight: bold;">Канальный уровень передаёт уже не отдельные биты, а целые сообщения. Определяет начало, конец сообщения в потоке бит</span>. Обнаруживает и исправляет ошибки. В широквещательной сети: управляет доступом к разделяемой среде передачи данных, выполняет физическую адресацию. <span style="font-style: italic; text-decoration: underline;">Единица: кадр. Устройство: Коммутатор, точка доступа.</span></div><div><span style="font-style: italic; text-decoration: underline;">Сетевой</span>. Задачи: Создание составной сети, согласование различий в сетях. Адресация(сетевые или глобальные адреса). Определение маршрута пересылки пакетов в составной сети(маршрутизация). <span style="font-style: italic; text-decoration: underline;">Единица: пакет. Устройство: маршрутизатор.</span></div><div><span style="font-style: italic; text-decoration: underline;">Транспортный</span>. Обеспечивает передачу данных между процессами на хостах. Управляет надёжностью: может предоставлять надёжность выше, чем у сети. Наиболее популярный сервис - защищённый от ошибок канал с гарантированным порядком следования сообщений. Сквозной уровень: Сообщения доставляются от источника адресату(от процесса отправителя процессу получателя). Предыдущие уровни используют принцип звеньев цепи. Он независимый, потому что происходит изоляция от сетевого оборудования. Единица: Сегмент/дейтаграмма</div><div><span style="font-style: italic; text-decoration: underline;">Сеансовый</span>: позволяет устанавливать сеансы связи: Управление диалогом(очерёдность передачи сообщений). Управление маркерами(предотвращение одновременного выполнения критичной операции).  Синхронизация(метки в сообщениях для возобновления передачи в случае сбоя). Единица здесь и далее: сообщение</div><div><span style="font-style: italic; text-decoration: underline;">Уровень представления</span><span style="text-decoration: underline;">:</span> обеспечивает согласование синтаксиса и семантики(смысла) передаваемых данных(форматы представления символов; форматы чисел). Шифрование и дешифрование. Пример: Transport Layer Security (TLS)/ Secure Sockets Layer (SSL) </div><div><span style="font-style: italic; text-decoration: underline;">Прикладной уровень:</span> набор приложений, полезных пользователям: Гипертекстовые Web-страницы, Социальные сети, Видео и аудио связь, электронаая почта, доступ к разделяемым файлам и др.</div><div><br/></div><div><img src="Evernote001.enex_files/Изображение.jpg" type="image/jpeg" data-filename="Изображение.jpg" width="914"/></div><div><br/></div><div>Модель TCP/IP:</div><div>Прикладной: HTTP, SMTP, DNS, FTP</div><div>Транспортный: TCP, UDP</div><div>Интернет(сетевой): IP - основной, ICMP, ARP, DHCP - вспомогательные</div><div>Сетевых интерфейсов: для ethernet, wifi, DSL, etc(эти технологии формально не входят в стек TCP/IP)</div><div><br/></div><div>Та же модель TCP/IP по версии Таненбаума:</div><div>Прикладной</div><div>Транспортный</div><div>Сетевой</div><div>Канальный: ethernet, wifi</div><div>Физический</div><div><br/></div><div>В протоколах HDLC &amp; PPP добавляются биты 01111110 в начало и конец кадра. Здесь 6 единиц подряд. Для того, чтобы решить проблему путаницы в данные после каждых 5 последовательных единиц добавляется ноль.</div><div>Преамбула(классический ethernet перед началом каждого кадра): длина 8 байт. Первые 7 байт: 10101010. Последний байт: 10101011(ограничитель начала кадра).</div><div>Передача неиспользуемых символов избыточного кода(Fast Ethernet) Начало кадра - пара символы J (11000) и K (10001). Конец кадра - символ  T (01101). </div><div><br/></div><div>Канальный уровень разделился, т.к. понадобилось присоединять к одной среде предачи данных несколько устройств . В итоге получили: Подуровень управления логическим каналом <span style="font-style: italic; text-decoration: underline;">Logical Link Control</span> отвечает за передачу данных(создание кадров, обработка ошибок и т.д.). Он общий для разных технологий. Услуги: мультиплексирование - передача данных разных протоколов(IP, ARP, ICMP) на уровень MAC; управление потоком - предотвращение &quot;затопления&quot; медленного получателя быстрым отправителем.; подуровень управления доступом к среде <span style="font-style: italic; text-decoration: underline;">Media Access Control</span>: совместное использование разделяемой среды. Адресация(нужно распределить доступ к разделяемой среде). Специфичный для разных технлогий. Не является обязательным(если соединение точка-точка(один к одному?)).</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Формат кадра ethernet II (DIX)</span>: 6 байт(Адрес получателя) 6 байт(Адрес отправителя) 2 байта(Тип(0800 - IPv4, 86DD - IPv6, 0806 - ARP)) это всё был заголовок. Дальше Данные(46-1500 байт(здесь также лежат данные от протокола верхнего уровня)), 4 байта (концевик)(контрольная сумма). В разных стандартах будут незначительные отличия. </div><div><br/></div><div>MAC-адреса служат для идентификации сетевых интерфейсов узлов сети Ethernet(IEEE 802.3), WI-FI(IEEE 802.11). Регламентированы стандартом IEEE 802. Длина 6 байт. Форма записи - 6 16-тиричных чисел: 1C-75-08-D2-49-45. Разделение м.б. серез двоеточие.</div><div><br/></div><div>Бывают: Индивидуальными(unicast) - данные получает только один компьютер</div><div>Групповыми(multicast, первый бит старшего байта адреса равен 1): 01-80-C2-00-00-08. - данные получают компьютеры входящие в группу. На компах д.б. настроен такой приём.</div><div>Широковещательными(broadcast, все 1): FF:FF:FF:FF:FF:FF</div><div><br/></div><div>Мак-адреса в одном сегменте сети не должны повторяться, иначе будут сбои в работе. Если мак адрес назначен производителем, то второй бит старшего байта мак адреса - 0, если назначен сетевым администратором -1. Для гарантии уникальности маков во всём мире есть стандарт: первые 3 байта - Organisation Unique Identifier. Последние 3 байта - назначает производитель оборудования, который отвечает за уникальность. Примеры OUI: 00-00-0С - Cisco, 00-02-B3 - Intel.</div><div><br/></div><div>Модель CSMA/CD для классического ethernet: есть периоды конкуренции. Есть период 9.6 мкс после передачи кадра все должны подождать. Низкая безопасность, максимальное число компьютеров - 30. Коллизии(если два компьютера начали передачу одновременно).</div><div><br/></div><div>Коммутатор работает на канальном уровне, т.к.  анализирует заголовок канального уроыня, извлекает оттуда адрес получателя и передаёт данные только на порт получателя.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Virtual Local Area Network</span></div><div>используется для изоляции сетей. Разные отделы организации, разные фирмы в бизнес-центре захотят иметь свои сети. Преимущества: безопасность, распределение нагрузки, ограничение широковещательного трафика. Для реализации VLAN в таблицу коммутатора добавляется ещё один столбец, в итоге имеем 3 столбца: Порт, MAC-адрес, VLAN. Соответственно 3-й столбец распределяет записи по виртуальным сетям. Это удобно(для прежнего формата кадра ethernet), если только 1 коммутатор в сети. Для создания VLAN в сети с несколькими коммутатормаи кадры должны нести в себе информацию о VLAN. Для  этого ввели стандарт 802.1Q по которому ethernet кадр изменился. Поле Тип - для этого стандарта 0x8100. Это уже не код протокола вышестоящего уровня, а указание на то, что кадр стандарта 802.1.Q. Дальше идёт 2 байта на Тег(номер VLAN сети) и 2 байта на Тип(Код протокола вышеcтоящего уровня(например, если у нас инкапсулирован IP-пакет версии 4: 0800). Соответственно длина всего кадра увеличена на 4 байта. В начале поддержка VLAN держалось только на коммутуторах. Сейчас большинство сетевых адаптеров поддерживают стандарт 802.1Q. Если информация передаётся с коммутатора на коммутатор, то... видимо здесь идёт переключение между стандартами кадров. В тип1 пишется 0x8100, в Тег номер вирт.сети, в Тип2 0x0800. Принимающий коммутатор извлекает информацию о вирт.сети., удаляет эту информацию из кадра, оставляет только тип(заменяет 8100 на 0800) 0x0800, пересылает этот кадр принимающему компьютеру.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол Spanning Tree Protocol связующего(остовного) дерева</span></div><div>Расположен на канальном уровне. Автоматически отключает дублирующие соединения в сети ethernet. Связующее дерево - подграф без циклов, содержащий все вершины исходного графа. Стандарт IEEE 802.1D позволяет создавать несколько соединений между коммутаторами. Преимущества: надёжность соединений между коммутаторами. Защита от ошибок конфигурации. Предотвращение широковещательного шторма. Т.о. если в сети есть кольца, то порты, создающие эти кольца просто отключаются. Однако если одно из соединений разорвётся, и отключённый порт понадобится, то он включится автоматически. Этапы работы: Выбор корневого коммутатора. Определение кратчайших путей до корневого коммутатора. Отключение всех остальных соединений(кроме кратчайших). Для реализации протокла коммутаторы обмениваются сообщениями: BPDU Bridge(используется термин Мост потомучто протокол был разработан в 80-е) Protocol Data Units отправляющимися каждые 2 секунды на груповой адрес STP 01:80:C2:00:00:00. Все коммутаторы поддерживающие STP принимают и обрабатывают сообщения, приходящие на этот групповой адрес. Корневым лучше вручную выбрать самый мощный. А вообще они все себя изначально считают корневыми и рассылают сообщения, сравнивая идентификаторы BID. Коммутатор с минимальным значением становится корневым. После выбора корневого все остальные рассчитывают кратчайшие пути до него. Путь между коммутаторами рассчитывается по двум параметрам: Количество промежуточных коммутаторов, скорость соединений. Потом коммутаторы рассылают на все порты BPDU с минимальным расстоянием от них до корневого коммутатора. например скорости 1 Гбит/с соответствует расстояние 4. Если следующих коммутаторов в ветви не 1, а 2 и скорость там такая же, то расстояние соотвтетственно до них удваивается до 8. Дальше одно из соединенйи нужно отключить, чтобы не было кольца. В итоге отключённый порт работает в режиме Blocking. Rapid STP работает быстрее, это стандарт IEEE 802.11w.  Чтобы реализовать с VLAN нужно для каждой виртуалки создавать своё связующее дерево. Это стандарт 802.1s Multiple Spanning Tree Protocol.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Сетевой уровень.</span> Одна из решаемых проблем - масштабируемость. На канальном уровне хорошо создавать локальные сети, но сложно глобальные. Уровень сервиса в разных сетях разный(гарантия доставки(подтверждение)). Адресация различается(Ethernet - MAC, Сети сотовой связи - IMEI). Широковещание может поддерживаться, а может и нет. Максмальный размер кадра Maximum Transmission Unit отличается в Ethernet 1500, Wi-Fi 2304байта . Формат кадра отличается. Масштабируемость невозможна из-за огромного числа MAC-адресов во всём мире. Такую таблицу мак адресов хранить и поддерживать очень затратно. Также отправка сообщений на все порты(...на всеь мир) будет занимать много лишних ресурсов. Также сложно обеспечить отсутствие дублируемости(колец). В общем решение: Агрегация адресов в блоки адресов - сети. Мусорные пакеты(без адресата) отбрасываются. Наличие нескольких путей в сети. Возможность выбора наилучшего пути - маршрутизация. У каждого интерфейса маршрутизатора в отличие от коммутатора есть свой адрес. ARP переделывает глобальный в локальный адрес. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">IP-адреса</span></div><div>Глобальные адреса используемые в стеке протоколов TCP/IP. Используются для уникальной идентификации компьютеров в составной сети. Подсеть - (IP-сеть, сеть, subnet) - множество компьютеров, у которых старшая часть IP-адреса одникаовая. Маршрутизаторы работают с подсетями, а не с отдеьными компьютерами. Маска подсети указывает где адрес сети, а где адрес хоста в этой сети. Индивидуальный адрес(unicast) назначается одному компу. Групповой(multicast) м.б. назначен нескольким компам. Маршрутизатор будет слать инфу им всем. Широковещательный(broadcast) состоит из адреса сети и всех остальных битов заполненных единицами. Маршрутизаторы не пересылают широковещательные пакеты. Т.е. передаются только внутри подсети. Это т.н. ограниченное широковещание(там используется айпи 255.255.255.255). Если же всё таки шлём через маршрутизатор из одной подсети в другую, то это называется &quot;направленное широковещание&quot; при этом указывается адрес подсети и все остальные биты как единицы. В номере хоста нельзя использовать только битовые нули или только битовые единицы. Все нули - адрес сети, а не хоста, все единицы - широковещательный адрес. Договорённость: хост с номером 1 - маршрутизатор по умолчанию(шлюз). 0.0.0.0 - адрес текущего хоста,использующийся, когда компьютер ещё не получил свой айпи. 255.255.255.255 - уже сказано(ограниченное широковещание). 127.0.0.0/8 - обратная петля(loopback) - сеть для тестирования. Данные не передаются в сеть, а приходят обратно. 127.0.0.1,8(можно использовать любой адрес из указанного диапазона) - localhost (текущий компьютер). 169.254.0.0/15 - Link-local адреса Назначаются ОС хоста автоматически, если недоступна другая конфигурация айпи. Могут использоваться в пределах подсети. Зарезервированные диапазоны адресов (RFC 1918) : <span style="font-style: italic; text-decoration: underline;">10.0.0.0./8, 172.16.0.0/12, 192.168.0.0/16 не маршрутизируются в Интернет.</span> Могут использоваться внутри организации без обращения в IANA Internet Assigned Numbers Authority - функция, реализуемая корпорацией ICANN Internet Corporation for Assigned Names and Numbers. Региональные регистраторы (RIR - Regional Internet Register) ICANN распределены для всех континентов. Для подключения организации, в которой используются эти пулы адресов к Интернет используется технология NAT Network Address Translation. С пом. этой технологии адрес из частной сети заменяется на реальный айпи адрес. Сейчас почти невозможно получить реальный IPv4, т.к. они уже все используются. Для решения исчерпаемости используется NAT &amp;/or IPv6. DHCP Dinamic Host Configuration Protocol используется для автоматического назначения IP-адресов. Он вместе с ARP на границе между сетевым и уровнем сетевых интерфейсов. <span style="font-style: italic; text-decoration: underline;">WhireShark показывает инкапсуляцию пакетов, кадров и т.п.</span>. </div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Формат заголовка IP-пакета:</span></div><div><img src="Evernote001.enex_files/Снимок экрана (02).png" type="image/png" data-filename="Снимок экрана (02).png" width="861"/></div><div>Номер версии айпи 4 или 6. Длина заголовка - длина этой части включает обязательные поля(всё до Опции и выравнивание), а также может включать дополнительные поля(те же Опции и выравнивание). Тип сервиса - редко используется сейчас. Общая длина - длина всего пакета, включая заголовок и данные. Измеряется в байтах. Максимум 65535 байт. На практике длина выьирается с учётом размера кадра канального уровня: 1500 байт для Ethernet. Идентификатор пакета, Флаги, Смещение фрагмента используются для фрагментации. Время жизнии(TTL) для предотвращения бесконечного продвижения пакетов. Измеряется в числе проходов через маршрутизаторы в прыжках(hop). Тип протокола - предназначено для реализации функции мультиплексирования/демультиплексирования. Код протокола следующего уровня, данные которого могут передаваться: TCP - 6, UDP - 17, ICMP - 1. Контрольная сумма - для проверки правильности доставки пакета. В опциях может быть: запись маршрута(адрес каждого маршрутизатора, через который пакет проходит записывается); Временные метки - время прохождения через каждый саршрутизатор записывается. Также можно задать маршрут отправителя(это м.б. жесткая маршрутизация, при которой указывается перечень маршрутизаторов, через к-рые необходимо пройти или м.б. свободная маршрутизация - указываются только некоторые маршрутизаторы, через которые пакет должен пройти обязательно). опции могут иметь разный размер. Длина заголовка при этом д.б. кратна 32 битам. Для выравнивания до 32 бит поле опций дополняется нулями. Сейчас опции почти не используются.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Маршрутизация???? </span>- поиск маршрута доставки пакета между сетями через транзитные узлы - маршрутизаторы. Этапы маршрутизации: изучение сети; Продвижение пакетов на маршрутизаторе. маршрутизатор отбрасывает пакеты с неизвестным маршрутом. На картинке виндовская таблица. Если сеть назначения находится в нескольких маршрутизаторах от исходного пункта, то пакет идёт дальше, но нужно помнить, что в таблице марщрутизатора хранятся только адреса для следующего шага на пути к конечной сети. Подразумевается, что все последующие маршрутизаторы знают маршрут также на 1 шаг вперёд. </div><div><img src="Evernote001.enex_files/Снимок экрана (03).png" type="image/png" data-filename="Снимок экрана (03).png" width="933"/></div><div>Записи в таблице маршрутизации м.б. статические. Это удобно в небольшой сети. Однако если сеть крупная и меняется, то лучше использовать динамические(автоматически настраиваемые) записи с помощью протоклов маршрутизации RIP, OSPF, BGP и др. Маршрутизатор должен знать обо всех существующих сетях, однако на практике, например для Интернет это невозможно. Поэтому есть маршрутизатор по умолчанию(шлюз, default router, gateway) - маршрутизатор, на который отправляются пакеты для неизвестных сетей. Обозначается: 0.0.0.0, маска 0.0.0.0; default. Обычно это маршрутизатор подключённый к интернету. На него отправляются пакеты для неизвестных сетей. Допустим маршрутизатор принял пакет с адресом получателя: 192.168.100.23. В таблице маршрутизации 2 записи: 192.168.100.0/24, 192.168.0.0/16. Будет выбран маршрут через первый маршрутизатор, т.к в нём больше префикс. Считается, что чем больше префикс(маска), тем больше шансов найти нужную сеть.Таблица маршрутизации есть не только у маршрузтиазаторов, но и у всех хостов сети. В них содержится: Присоединённая сеть, маршрутизатор по умолчанию(шлюз, gateway), (не обязательно) маршруты к знакомым сетям. Если адрес из другой подсети, то данные должны уйти на шлюз по умолчанию.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол IP: Фрагментация</span> Идентификатор пакета - поле айпи заголовка - д.б. одинаковым во всех фрагментах пакета. Поле Флаги - первый бит зарезервирован и не используется, DF - dont fragment, MF - more fragments - ещё есть фрагменты. Смещение фрагмента - поле для понимания того в каком порядке собирать фрагменты, оно нужно, т.к. врагменты могут прийти не в том порядке. Фрагменты могут быть 1500-20(размер айпи заголовка) = 1480 байт. Пусть надо передать пакет размером 4000 байт(заголовок 20 байт, данные 3980). MTU целевой сети 1500 байт.( заголовок 20 байт, данные 1480). Три фрагмента данных: 01479б 1480-2959, 2960-3980. Делим каждое первое число на 8 байт, получаем 0, 185, 370 - значения поля смещения. В IPv6 фрагментация не делается.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Управляющие протоколы сетевого уровня: DHCP</span> нужен DHCP сервер и инфраструктура. Сервер - компьютер, который назначает айпи адреса, ведёт таблицу выделенных айпи адресов, чтобы избежать дублирования. Клиент и сервер обмениваются сообщениями DHCP в режиме запрос-ответ. Клиент включается в первый раз. Шлёт сообщение широковещательно(все F) сообщение DHCP-Discover. Сервер предлагает айпишник, клиент соглашается и просит зарегать. Сервер отвечает подтверждением. DORA Discover Offer Request Acknowledge. Адрес выдаётся на ограниченный срок(аренда).</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">ARP Adress Resolution Protocol</span> Dns всё равно превращаются в айпи адреса. Коммутатор Ethernet ничего не знает об айпи адресах. В линуксе в файле /etc/ethers есть табличка соотвтетствия известных мак адресов айпи адресам. Но в крупной сети так не работает. ARP позволяет определить мак по айпи. Например чтобы узнать мак , комп может послать арп-запрос с айпишником широковещательно(на все F) и в итоге получить от нужного компа сообщение с айпи и маком. АРП разрабатывался в расчете на использование не только в Ethernet, поэтому у него есть такие поля, как на картинке. АРП не проходят через маршрутизатор(т.к. широковещательные запросы не проходят через маршрутизатор, ну и арп ниже сетевого уровня изначально). Компьютеры записывают информацию о найденных мак адресах в кеш. В итоге нет необходимости запрашивать мак адрес при каждом отправлении. АРП-таблица хранит данные о соотвтетствии мак и айпи адресов. Так же там есть столбец Тип, в нём указано динамическая или статическая(внесена вручную) эта запись в таблице.</div><div><img src="Evernote001.enex_files/Снимок экрана (04).png" type="image/png" data-filename="Снимок экрана (04).png" width="904"/></div><div>АРП-ответ такой же, только операция №2.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">ICMP</span> Internet Control Message Protocol предоставляет сервис передачи данных без гарантии доставки. Информация об ошибках всё же передаётся по протоколу ICMP. В функции также входит тестирование работоспособности сети. Формат заголовка ICMP: 1 байт Тип сообщения(какая ошибка, например 0 - эхо-ответ, 3 - узел назначения недостижим, 5 - перенаправления маршрута), 1 байт Код сообщения(тип ошибки или её причина или диагностическое действие, например 0 - сеть недостижима, 1 - узел недостижим, 2 протоколо недостижим, 3 порт недостижим и т.д. ), 2 байта Контрольная сумма, 4 байта Зависит от типа и кода сообщения, Поле данных(обычно сюда включается фрагмент пакета, при передаче которого произошла ошибка). Утилиты: ping, traceroute, tracert(для винды). Как работает traceroute: посылается ICMP сообщение с TTL=1, при этом первый же маршрутизатор уменьшает TTL до 0 и отбрасывает пакет, отправляя сообщение ICMP Тип  = 11, Код = 0, время жизни истекло. Утилита из заголовка IP-пакета, в который вложен ICMP извлекает IP-адрес маршрутизатора. На следующем этапе отправляется сообщение с TTL Time To Live = 2. Всё повторяется. Т.о. все маршрутизаторы отслеживаются. Никто не обязан обрабатывать ошибки о которых сообщает протокол. Можно в командной строке запустить tracert vk.com. Покажет адреса всех маршрутизаторов на пути к вк.</div><div><br/></div><div>Сдаю лабу один за всю группу:</div><div><br/></div><div>icmp is incapsulated in IP Преподаватель: &quot;лучше не говорить слово - инкапсулировано&quot;</div><div><br/></div><div>icmp tells that address ip is not found</div><div><br/></div><div>mac address is written</div><div><br/></div><div>таблица маршрутизаци</div><div><br/></div><div>на узле две таблицы мак адресов(арп таблица) и таблица маршрутизации</div><div><br/></div><div>хакер - это хороший системный программист</div><div><br/></div><div>коммутатор с таблицей коммутации</div><div><br/></div><div>в арп таблице есть айпишники</div><div><br/></div><div>Почему все интерфейсы маршрутизатора доступны даже на канальном уровне всем участникам сети? </div><div>Интерфейс маршрутизатора считается уже частью сети, к которой он подключён? </div><div>А сам маршрутизатор находится при этом в нескольких сетях одновременно?</div><div><br/></div><div>Где начинается ситуация, когда маршрутизатор начинает видеть мак-адреса следующей сети?(преподаватель сказал, что он их не видит, однако ниже написано про передачу пакетов на сетевом и канальном уровне и там написано, что эти мак-адреса дрступны....)</div><div><br/></div><div>ОС сама знает где шлюз по умолчанию? Или его надо указывать?</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Передача пакетов на сетевом и канальном уровнях</span> Например в одном сегменте сети происходит передача. Имеется отправитель с айпишником и маком и получатель в той же сети с айпи и маком. Начинаем формировать пакет. В адрес отправителя включаем его айпи и мак, в адрес получателя включаем айпи-адрес получателя, <span style="font-style: italic; text-decoration: underline;">но, как правило</span>(<span style="font-style: italic; font-weight: bold; text-decoration: underline;">ПОЧЕМУ?</span> видимо потому, что айпи может часто меняться, т.к. он роздан, например, через DHCP и его соотвтетствие маку может быть уже не актуальным... <span style="font-style: italic; font-weight: bold; text-decoration: underline;">Нет. Созыкин говорит, что мак-адреса всё время меняются</span>)<span style="font-style: italic; text-decoration: underline;">мак-адреса получателя мы не знаем</span><span style="font-style: italic;">)</span>. Для получения этих данных используется протокол АРП широковещательно. Дополняем заголовок пакета мак-адресом, отправляем, получаем ответ от получателя с соотвтетсвующими полями. АРП-запрос при этом обычно не нужен, т.к. получатель считал его из первого сообщения. Другая ситуация: компьютер находится в другой сети: опять в заголовке айпи и мак, и для получателя только айпи. Сначала берём адрес нашей сети и проверяем адрес получателя, находится он в этой сети или нет(с помощью маски).  Понимаем, что напрямую пакет не передать. Только через маршрутизатор. Получаем адрес маршрутизатора из таблицы маршрутизации на компьютере(у каждого интерфейса маршрутизатора есть айпи и мак адрес). АРП-ом узнаём мак-адрес маршрутизатора. ВНИМАНИЕ записываем этот мак в заголовок как мак получателя(айпишник получателя остаётся прежним(для компа получателя)). Шлём пакет на маршрутизатор. Он его принимает и из своей таблицы уже прописывает в заголовок мак получателя для получателя, а в мак отправителя прописывает свой мак(уникальный именно для той  второй сети). Здесь нарисован один маршрутизатор, на самом деле их походу два. </div><div><img src="Evernote001.enex_files/Снимок экрана (05).png" type="image/png" data-filename="Снимок экрана (05).png" width="735"/></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Транспортный уровень</span> его задача - передача данных между процессами на разных хостах. Уровни начиная с транспортного работают только на хостах. Обеспечивает т.н. сквозное соединение. Позволяет скрыть от разработчиков приложений детали сетевого взаимодействия, поэтому называется независимым. Для адресации используются т.н. порты. Адрес на транспортном уровне - число от 1 до 65535. Каждое сетевое приложение на хочте имеет свой порт. Номера портов у приложений не повторяются. Форма записи: 192.168.1.3:80 (здесь до двоеточия айпишник, после - порт). Хорошо известные порты: 1-1024: 80 - HTTP(Web), 25 - SMTP(Электронная почта), 53 - DNS, 67,68 - DHCP. Их может использовать только root/администратор. Зарегистрированные порты: 1025-49151 - регистрация в IANA. Динамические порты: 49151-65535 - автоматически назначаются ОС сетевым приложениям. Веб может использовать и другие порты, например 8080. Это первый сетенезависимый уровень. Может обеспечить более надёжную дотавку данных, чем сетевой уровень).</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">UDP User Datagram Protocol </span> протокол дейтаграмм пользователя. Сообщение UDP называется дейтаграммой(по аналогии с телеграммой). Особенности: нет соединения. Нет гарантии доставки данных. Нет гарантии сохранения порядка сообщений. Надёжность доставки по сравнению с IP не повышается. На транспортном уровне указывается порт отправителя и порт получателя(основная задача UDP), в айпи этого нет, поэтому голый айпи подойдёт не всегда. Длина UDP(всей дейтаграммы): минимум 8 байт(только заголовок), максимум 65515 байт(максимальная длина данных айпи пакета). Преимущество UDP в скорости работы(по сравнению с TCP), отсутствии накладных расходов на установку соединения. Надёжность: в современных сетях ошибки происходят редко. Ошибку в любом случае обработает приложение. Область применения: клиент-сервер, короткие запрос-ответы. Пример применения UDP: ситема доменных имён DNS. Она позволяет определить по доменному имени айпи адрес. <a href="http://www.cisco.com/">www.cisco.com</a> -&gt; 184.86.0.170. Система днс использует UDP, порт 53. Клиент днс может сделать udp запрос к днс серверу: какой айпи у <a href="http://www.cisco.com/">www.cisco.com</a>? и получить ответ: 184.86.0.170. TCP для той же операции понадобилось бы 9 сообщений. Если запрос потерялся, приложение запускает таймер. По истечении таймера отправляет опять запрос. </div><div><img src="Evernote001.enex_files/Снимок экрана (6).png" type="image/png" data-filename="Снимок экрана (6).png" width="927"/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP</span> Transmission Control Protocol протокол управления передачей. Сервис TCP: надёжная передача потока байт(reliable byte stream). Гарнатии TCP: доставка данных, сеохранение порядка следования сообщений. Транспортная подсистема получает от приложения данные в виде потока байт. В пртоколле тисипи поток разбивается на отдельные части - сегменты. Сегменты передаются отдельно от отправителя к получателю. Получатель  собирает сегменты и передаёт принимающему приложению поток байт. После получения каждого сегмента получатель отправляет подтверждение(Acknowledgment, ACK). Только получив подтверждение отправитель продолжает отправку. Если же произошла ошибка при передаче данных, сегмент не дошёл, подтверждение не отправляется. Отправитель ждёт подтверждение по  таймеру. Если подтверждение не пришло, тот же сегмент отправляется повторно. На самом деле подтверждается не каждый сегмент, а несколько сегментов, отправленных друг за другом. Это реализуется с помощью механизма скользящего окна. Возможно дублирование сегментов, если ACK потерялся, получатель отправит тот же сегмент ещё раз. Поэтому встроен механизм  защиты от дублирования. Нумеруются не сегменты, а байты - например номер первого байта(0), получатель(получив все байты вплоть до номера 1023) отправляет подтверждение: жду байт № 1024, передаётся сегмет с номером первого байта 1024 и так далее. Перед отправкой данных по TCP требуется установка соединения. Задачи соединения: убедиться, что отправитель и получатель хотят передавать данные друг другу; договориться о нумерации потока байт; договориться о параметрах соединения(максимальный размер сегмента и т.п.). После завершения передачи данных соединеияе разрывается. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: скользящее окно</span> Варианты подтверждения доставки: остановка и ожидание(Wi-Fi, канальный уровень); скользящее окно(TCP, транспортный уровень). </div><div><img src="Evernote001.enex_files/Снимок экрана (7).png" type="image/png" data-filename="Снимок экрана (7).png" width="823"/></div><div>Почему на транспортном уровне эффективнее использовать скользящее окно: сообщение передаётся не мгновенно(время передачи короктое, но не нулевое). В среде может &quot;находиться&quot; некоторый объём данных: Скорость*задержка  Кумклятивное подтверждение(о том, что получен последний байт и все предыдущие) не выгодно на больших файлах, т.к. оно запросит передачу, например всех 500мегабайт данных, даже если не получен всего один последний байт. Окно м.б. 1 гигабайтом. Поэтому реализовано выборочное подтверждение Selective Acknowledgment (SACK): оно подтверждает получение диапазонов принятых байт(например от 0 до 49 получил, 50-55 - не получил) и запрашивает прислать повторно только диапазон 50-55. По умолчанию в TCP работает кумулятивное подтверждение. Чтобы включить выборочное, нужно указать дополнительное поле заголовка TCP(параметр). Скользящее окно нужно для передачи данных по протяженным высокоскоростным каналам передачи данных, чтобы за счёт уменьшения времени ожидания подтверждения не потерять в скорости.</div><div><img src="Evernote001.enex_files/Снимок экрана (9).png" type="image/png" data-filename="Снимок экрана (9).png" width="451"/>-&gt; <img src="Evernote001.enex_files/Снимок экрана (12).png" type="image/png" data-filename="Снимок экрана (12).png" width="471"/>-&gt;<img src="Evernote001.enex_files/Снимок экрана (13).png" type="image/png" data-filename="Снимок экрана (13).png" width="459"/>-&gt; <img src="Evernote001.enex_files/Снимок экрана (14).png" type="image/png" data-filename="Снимок экрана (14).png" width="459"/></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: соединение</span> Отправитель посылает запрос на установку соединения SYN(synchronize), байт 7537 (порядковый номер байта). Получатель отправляет такое же сообщение SYN, байт 36829<span style="font-style: italic;">(номер байта в потоке байт, для простоты можно считать, что эти номера7537 и 36829) выбираются случайно(хотя на самом деле там есть сложный алгоритм того, как их называть))</span>, ACK 7538<span style="font-style: italic;">(подтвердил и ожидает номер байта 7538)</span> . 3-й Этап - отправитель шлёт: Байт 7538(номер байта в сообщении), ACK 36830(подтвердил получение запроса на установку соединения, номер следующего ожидаемого байта 36830). Произведено т.н. трёхкратное рукопожатие. После этого соединение считается установленным. Соединение в TCP дуплексное. Это значит, что после установки соединения передавать данные можно в две стороны. Схемы разрыва соединения: Одновременное(обе стороны разрвали соединение); Одностороннее(одна сторона прекращает передавать данные, т.к. данные закончились, но другая сторона может передавать данные ещё достаточно долго, а первая принимать). Варианты разрыва соединения: Одностороннее закрытие(корректное) - (первый шлёт сообщение FIN, получает ACK и больше отправлять ничего не может, а второй может ему послать ещё данные, но когда они закончатся, также шлёт на первый FIN, получает ACK) ; Разрыв из-за критической ситуации(RST) Один шлёт RST и соединение закрывается в обе стороны. Хотя изначально это для критических ситуаций, некоторые протколы могут использовать это сообщение для быстрого закрытия соединения. Накладные расходы в TCP выше, чем в UDP, но установление соединения позволяет гарантировать доставку и доставку в строго определённом порядке.</div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: формат заголовка</span> протокол TCP - самый сложный в курсе лекций. </div><div><img src="Evernote001.enex_files/Снимок экрана (16).png" type="image/png" data-filename="Снимок экрана (16).png" width="783"/></div><div>Назначение большинства полей понятно из названий. Порты позволяют определить приложение, которому предназначен сегмент.Порядковый номер содержит номер байта в сегменте. (в Ethernet размер сегмента обычно 1460(сегмент) + 20(заголовок тисипи) + 20(заголовок айпи) = 1500байт. Номер подтверждения - используется обычно для гарантии доставки сообщений при кумулятивном подтверждении. Серый прямоугольник - неиспользуемые зарезервированные биты. Дальше 9 полей флагов: первые 3 для управления перегрузкой. URG - urgent говорит о том, что в сегменте содержатся срочные данные, которые необходимо срочно передать приложению. А поле &quot;Указатель на срочные данные&quot; содержит адрес этих данных. ACK - записывается, если в поле &quot;Номер подтверждения&quot; записаны осмысленные данные. PSH - push - указывает, что данные нужно передать приложению без промежуточной записи в буфер. Сейчас не используется, как и флаг URG. RSt &amp; FIN - для разрыва соединения. SYN - для установки соединения. Размер окна - указывает сколько данных получатель сможет принять. Поле используется для управления потоком. Контрольная сумма - получатель рассчитывает контрольную сумму сам и сравнивает с этой. Параметры в TCP(в отличие от айпи) используются часто: MSS maximum segment size(1460 для этернет) устанавливается при установке соединения. Масштаб окна - позволяет изменить размер окна до 1 Гб.  Выборочное подтверждение SACK - позволяет получить подтверждение диапазона принятых байт. Метки времени - для диагностических целей. Сегменты без данных могут использоваться например при установке соединений. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: управление потоком</span> В сети м.б. устройства разной производительности. Управление потоком(flow control): предотвращает &quot;затопление&quot; медленного получателя быстрым отправителем. Также приложение м.б. занято какими-то другими важными делами и в отличие от коммутаторов и марщрутизторов не обязано сразу обработать информацию. В итоге буфер приложения может оказаться переполненным. Для решения этой проблемы тспользуется поле &quot;размер окна&quot; в заголовке тисипи. Там указывается сколько байт может быть принято. Этот размер рассчитывается как остаток свободного места в буфере получателя. Т.о. в первом пакете м.б. &quot;пробные 2500 байт, потом, когда отправителю придёт &quot;ACK, 2501, размер окна 10220&quot;, он передаст уже несколько пакетов сразу, которые могут заполнить буфер до максимума. В итоге, если место закончилось, получатель отправит &quot;ACK, 10221, размер окна 0&quot;. Иногда отправитель при длительном простое может послать запрос Zero Window Probe о том, является ли всё еще размер окна равным нулю. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: управление перегрузкой</span> В буфере получателя м.б. достаточно свободного места, но сеть, через которую передаются данные перегружена. При этом пакеты, поступающие на маршрутизаторы отбрасываются. Коллапс перегрузки (congestion collapse) произошёл в Интернет в 1986. Каналы связи загружены полностью. Скорость передачи данных между хостами падала на порядок. Чтобы решить проблему: можно вести учёт загрузки сети при определении размера окна; традиционный подход: фиксированное окно 8 сегментов; предложенный подход - размер окна меняется динамически в зависимости от нагрузки на сеть; механизм реализации - окно перегрузки. Это окно заполняется отправителем. Оба окна - окно перегрузки и окно управления потоком используются для решения более общей задачи - управления скоростью передачи данных в тисипи. В итоге необходимо определить оптимальный размер окна(чтобы не перегрузить маршрутизаторы, но и не урезать сильно скорость передачи). Для этого используется метод аддитивного увеличения, мульипликативного уменьшения - Additive increase/multiplicative decrease. </div><div><img src="Evernote001.enex_files/Снимок экрана (17).png" type="image/png" data-filename="Снимок экрана (17).png" width="550"/><img src="Evernote001.enex_files/Снимок экрана (18).png" type="image/png" data-filename="Снимок экрана (18).png" width="494"/></div><div>т.о. при перегрузке размер окна уменьшается в 2 раза. Отправитель узнает о перегрузке не всегда качечтвенно. Ведь сеть может быть составной, и перегрузка может происходить не на том сегменте сети, к-рый подключен к отправителюа, а на каком-то сегменте, к-рый нах-тся от отправителя и получателя достаточно далеко. Чаще всего в кач-ве сигнала о перегрузке использ. &quot;потеря сегмента&quot; (считается, что сейчас качество сетей хорошее и если произошла потеря сегмента, то не из-за ошибки канала, а из-за того, что сеть перегружена. Есть также &quot;задержка сегмента&quot; и сигнал от маршрутизатора - Explicit Congestion Notification ECT. Проблема AIMD - медленный(линейный) рост размера окна перегрузки. Это приемлемо на медленных каналах, но не приемлемо на быстрых и надёжных. Был предложен другой метод - медленный старт: первоначально размер окна перегрузки устанавливается маленьким(1 или 4 сегмента); при каждом получении подтверждения отправляется 2 сегмента (т.е. рост не на 1 сегмент, а на 2); экспоненциальный рост размера окна; недостаток - после сигнала о перегрузке начинаем сначала. В тиспи используется комбинация медленного старта и AIMD. </div><div><img src="Evernote001.enex_files/Снимок экрана (19).png" type="image/png" data-filename="Снимок экрана (19).png" width="476"/></div><div>Порог медленного старта рассчитывается так: как только пришёл сигнал о перегрузке, размер окна уменьшается в 2 раза и с этого момента начинается аддитивное увеличение. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Протокол TCP: управление перегрузкой часть 2</span> существует 3 вида сигналов: потеря сегмента, задержка сегмента и явный сигнал от мрашрутизатора. Если использовать потерю сегмента как сигнал о перегрузке, то тисипи фактически начнёт работать в режиме, который ведёт к перегрузке: размер окна постоянно увеличивается; окно начинает уменьшаться только после того, как перегрузка произошла. Вторая проблема - глобальная синхронизация TCP - TCP Global Synchronization: место в буфере маршрутизатора заканчивается, он отбрасывает все новые сегменты; отправители получают сигнал о перегрузке и уменьшают размер окна; передача данных начинается всеми отправителями почти одновременно. В результате опять приходит большое число пакетов, что ведёт к перегрузке. Для решения этой проблемы может использоваться информация о задержке сегмента. В этом случае измеряется т.н. round trip time - время движения сегмента от отправителя до получателя и обратно. Отправитель передавая сегменты, засекает rtt и при существенном увеличении времени уменьщает размер окна перегрузки. Это позволяет обнаружить перегрузку до того, как она произошла. Но задержка м.б. вызвана не только перегрузкой, но и другими причинами. Поэтому задежка - не такой надёжный сигнал, как потеря сегмента. Другая проблема в том, что существует &quot;несправедливость&quot; на загруженных каналах: размер окна уменьшается при задержке сегмента, а другие отправители уменьшают только при потерях сегмента. Решение- совместное использование сигналов задержка и потеря сегментов. Пример: Compound TCP компании Microsoft. Следующий вариант оповещения о перегрузке - сигнал от маршрутизатора: Random Early Detection - маршрутизатор начинает отбрасывать пакеты ещё до того, как началась перегрузка. В результате отправители узнают о надвигающейся перегрузке до того, как она произошла. Однако это не явный тип сигнала.; Explicit Congestion Notification - обеспечивает явную отправку сигнала от маршрутизатора к отправителю о том, что в сети происходит перегрузка. Например пакет передан на маршрутизатор близкий к перегрузке. В заголовке айпи маршрутизатор устанавливает соотвтествующий флаг и отправляет пакет дальше. Компьютер получателя прописывает информацию о перегрузке уже на транспортном уровне ответного сообщения. Отправитель получает подтверждение доставки сообщения и в этом потверждении он увидит, что флаг, сигнализирующий о перегрузке установлен. Это будет сигналом о том, что нужно уменьшить размер окна перегрузки. Для реализации ECN в заголовке айпи используются два(последних?) бита в поле &quot;тип сервиса&quot;: 00 - перегрузки нет; 11 - перегрузка произошла. В заголовке тисипи 3 флага: ECE(ECN-Echo) - устанавливается получателем при получении сигнала о перегрузке от маршрутизатора; CWR(Congestion Window Reduced) - устанавливается отправителем для подтверждения получения сигнала о перегрузке; NS(ECN-nonce concealment protection) - защита от случайного или злонамеренного изменения флагов ECN. </div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Интерфейс сокетов</span> применяется для взаимодействия между разными уровнями. Сокет в UNIX - файл специального типа. Вы пишете данные в этот файл, они автоматически передаются по сети на другой компьютер. Он может прочитать данные оттуда тоже как из обычного файла, хотя на самом деле они пришли по сети. Т.о. взаимодействие с сетью скрыто от программиста. Такая абстракция оказалась очень удобной и сокеты начали использовать и в других ОС. Сокеты - де-факто стандарт для взаимодействия  программ с транспортным уровнем стека протоколов TCP/IP. Операции сокетов Беркли использует модель клиент-сервер. Socket - создать новый сокет. Bind - связать сокет с айпи адресом и портом. Listen - объявить о желании принимать соединения. Accept - принять запрос на установку соединения. Connect - уставноить соединение.  Send - отправить данные по сети. Receive - получить данные из сети. Close - закрыть соединение. В других реализациях эти команды могут незначительно отличаться. Взаимодействующие стороны сокетов Беркли: Сервер, клиент. Сервер работает(слушает) на известном айпи адресеи порту и пассивно ждёт запросов на соединение. Клиент активно устанавливает соединение с сервером на заданном айпи и порту. </div><div><img src="Evernote001.enex_files/Снимок экрана (21).png" type="image/png" data-filename="Снимок экрана (21).png" width="620"/>-&gt;<img src="Evernote001.enex_files/Снимок экрана (20).png" type="image/png" data-filename="Снимок экрана (20).png" width="624"/></div><div>Есть два компьютера. Сначала надо создать сокет на сервере и сдеалть так, чтобы он мог принимать запрос на соединение. Socket - создание объекта сокет. Bind привязывается к айпи и порту 80. Вызов LIsten говорит о том, что сокет готов приниматьсоединение по сети. Сокет слушает. При вызове Listen создаётся очередь для соединений. В вызове необходимо указать размер этой очереди. У нас 5. Если сервер получит больше 5 запросов на соединение, а предыдущие запросы ещё не будут обработаны, то все новые запросы будут отбрасываться. Затем сервер вызывает метод сокета Accept. Это говорит о том, что сервер готов принимать соединения и он переходи в режим пассивного ожидания. Ждёт запросов на установку соединений от клиента. Клиент со своей стороны сначала также вызывает метод Socket для создания сокета. как правило для клиента не имеет значения какой айпи адрес и какой порт используется. Номер порта назначается ОС. Поэтому метод Bind на клиентском сокете обычно не вызывается. Хотя это можно сделать. Сразу после создания сокета вызывается метод Connect, в котором указываются айпи алрес и порт. В параметрах метода Connect указываются айпи адрес сервера и порт с которыми нужно установить соединеие. Отправляется запрос на соединение. Затем происходит важная вещь: для того, чтобы другие клиенты могли соединяться с этим сервером на этом айпи адресе и на этом же порту, создаётся копия сокета и соединение уже устанавливается не с исходным сокетом, который принимет соединения, а с копией сокета, и данные передаются уже через копию сокета. Клиент подготавливает порцию данных, вызывает метод Send. Данные передаются по сети и сервер может их прочитать с помощью метода Receive. Дальше сервер и клиент могут обмениваться между собой несколькими порциями данных. После того, как все данные переданы клиент вызывает метод Close, после чего происходит разрыв соединения.  Пример на питоне - Серверный сокет:</div><div><br/></div><div>import socket//импортировали модуль сокет. Дальше работа с коетами выполняется почти также как в модели сокетов Беркли</div><div><br/></div><div>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)//сначала создаём сокет. Сначала указываем протокол сетевого уровня специальными константами(здесь socket.AF_INET - значит айпи) и протокол транспортного уровня(здесь socket.SOCK_STREAM - значит TCP). </div><div>s.bind(('192.168.0.1', 8888))//с помощью метода Bind привящываем порт и айпи</div><div>s.listen(1)//говорим о том, что готовы принимать соединения и очередь соединения состоит из одного элемента</div><div>conn, addr = s.accept()//ждём от клиентов запросов на соединение. Возврат из метода accept произойдёт только после того как какой-то из клиентов установит соединене.</div><div>while True://в цикле читаем данные порциями по 1024 байта с пом. метода recieve(recv)</div><div>    data = conn.recv(1024)</div><div>    if not data: break//выход из цикла когда данные закончатся</div><div>    conn.sendall(data)//и просто отправляем те же самые данные обратно</div><div>conn.close()//после этого закрываем соединение</div><div><br/></div><div>Протоколы сетевого уровня: socket.AF_INET - IPv4, socket.AF_INET6 - IPv6. Протоколы транспортного уровня: socket.SOCK_STREAM - TCP, socket.SOCK_DGRAM - UDP. Есть и другие типы, но они используются редко. </div><div>Пример на питоне - Клиентский сокет:</div><div><br/></div><div>import socket</div><div><br/></div><div>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)// Bind здесь вызывается ОС автоматически</div><div>s.connect(('192.168.0.1', 8888))//</div><div>s.sendall(b'Hello, world!')</div><div>data = s.recv(1024)</div><div>s.close()</div><div>print('Получение данных:', repr(data))</div><div><br/></div><div>В итоге протколы транспортного уровня скрыты от програаммиста, он нигде не создаёт соединение с помощью трёхкратного рукопожатия, не устанавливает флаги FINN или RST для разрыва соединения и не делает других подобных вещей, которые используются в протоколе TCP. Т.о. если в будущем протоколы TCP or UDP поменяются, то не нужно будет переделывать программу. Именно для этих целей введено разделение между интерфейсами и протоколами компьютерных сетей. </div><div><br/></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Switch</span> sends: STP(every 2 seconds all the time) -&gt; DTP(every 30 seconds) -&gt; CDP(every minute)</div><div>Switch&gt;show mac-address-table через 4.5 минуты уже не показывает известные ранее мак-адреса таблицы, кроме мак-адреса интерфейса роутера, к которому подключён этот свич. На других коммутаторах также сохраняются адреса портов других коммутаторов, подключённых к портам исходного коммутатора.</div><div style="border-bottom: solid 1px #aaaaaa;"><div style="margin: 4.22mm 0mm 1.06mm; text-indent: 0mm; min-height: 13pt;"><span style="text-indent: 0mm; min-height: 13pt; font-size: 12pt; font-family: Georgia; font-weight: bold;">DTP (Dynamic Trunking Protocol)</span></div></div><div style="margin: 0mm 0mm 2.11mm; text-indent: 0mm; min-height: 9pt;"><span style="text-indent: 0mm; min-height: 9pt; font-size: 12pt; color: rgb(37, 37, 37); font-family: Arial;">DTP (англ. </span><span style="text-indent: 0mm; min-height: 9pt; font-size: 12pt; color: rgb(37, 37, 37); font-family: Arial; font-style: italic;">dynamic trunking protocol</span><span style="text-indent: 0mm; min-height: 9pt; font-size: 12pt; color: rgb(37, 37, 37); font-family: Arial;"> — динамический протокол транкинга) — проприетарный сетевой протокол канального уровня, разработанный компанией Cisco для реализации транкинговой системы</span> <span style="text-indent: 0mm; min-height: 9pt; font-size: 14pt; color: rgb(37, 37, 37); font-family: Arial; font-weight: bold;">для связи в сети VLAN между двумя сетевыми коммутаторами</span> <span style="text-indent: 0mm; min-height: 9pt; font-size: 14pt;"><span style="font-size: 14pt; color: rgb(37, 37, 37); font-family: Arial; font-weight: bold;">и для реализации инкапсуляции</span></span><span style="text-indent: 0mm; min-height: 9pt; font-size: 12pt; color: rgb(37, 37, 37); font-family: Arial;">. Также DTP является собственным протоколом компании</span><span style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;"> </span><a href="https://ru.bmstu.wiki/Cisco_Systems%2C_Inc.%20%5Co%20Cisco%20Systems%2C%20Inc." style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(36, 93, 193); font-family: Arial; text-decoration: underline;">Cisco Systems, Inc.</a><span style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">, который позволяет коммутаторам динамически определять если соседний коммутатор настроен для поднятия транка между портами коммутаторов и какой протокол использовать (</span><a href="https://ru.bmstu.wiki/VMQ_%28Virtual_Machine_Queue%29%20%5Co%20VMQ%20%28Virtual%20Machine%20Queue%29" style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(36, 93, 193); font-family: Arial; text-decoration: underline;">802.1Q</a><span style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;"> или </span><a href="https://ru.bmstu.wiki/ISL_%28Inter-Switch_Link%29%20%5Co%20ISL%20%28Inter-Switch%20Link%29" style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(36, 93, 193); font-family: Arial; text-decoration: underline;">ISL</a><span style="text-indent: 0mm; min-height: 9pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">)</span></div><div style="margin: 0mm 0mm 2.11mm; text-indent: 0mm; min-height: 6pt;"><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Согласование характеристик магистральных каналов с использованием динамического протокола ISL (Dynamic ISL — DISL) или </span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial; font-weight: bold;">динамического протокола формирования магистральных каналов (DTP)</span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;"> позволяет двум соединенным между собой портам согласовать решение о том, должны ли они стать портами магистрального канала. Такое согласование применяется для того, чтобы администратору не приходилось настраивать конфигурацию с обеих сторон магистрального канала и достаточно было выполнить настройку только с одной стороны. Порт, находящийся на другом конце канала, может выполнить настройку требуемых параметров автоматически. Автор предпочитает настраивать все порты магистральных каналов вручную, поскольку автоматическое согласование обычно не позволяет сэкономить столь существенное время (но печально известно тем, что нарушения в его работе приводят к большим неприятностям).</span></div><div style="margin: 0mm 0mm 2.11mm; text-indent: 0mm; min-height: 12pt;"><span style="text-indent: 0mm; min-height: 12pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Существуют следующие настройки режима порта коммутатора:</span></div><ul style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt; list-style-type: disc;"><li style="margin-left: 27pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Access — ставит Ethernet-порт в режим постоянного бестранкового состояния и преобразовывает канал связи в бестранковый. Ethernet-порт становится бестранковым, даже если соседний порт не согласен с изменением.</span></div></li><li style="margin-left: 27pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Trunk — переводит порт Ethernet в постоянный режим транкинга и согласовывает с другими портами, чтобы преобразовать канал связи в одиночный канал связи; порт становится транк-портом даже если соседний порт не согласен с изменением.</span></div></li><li style="margin-left: 27pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Dynamic Auto — делает порт Ethernet готовым преобразовать канал связи в одиночный канал связи; порт становится транк-портом, если соседний порт установит режим Trunk или Dynamic Desirable; этот режим используется по умолчанию для всех портов </span><a href="https://ru.bmstu.wiki/AoE_%28ATA_over_Ethernet%29%20%5Co%20AoE%20%28ATA%20over%20Ethernet%29" style="font-size: 10pt; color: rgb(36, 93, 193); font-family: Arial; text-decoration: underline;">Ethernet</a><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">.</span></div></li><li style="margin-left: 27pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Dynamic Desirable — порт активно пытается преобразовать канал связи в одиночный канал связи; порт становится транк-портом, если соседний Ethernet-порт установит режим Trunk, Dynamic Desirable или Dynamic Auto.</span></div></li><li style="margin-left: 27pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Nonegotiate — отключает DTP, порт не будет отправлять DTP-кадры или использовать входящие DTP-кадры; чтобы установить одиночный канал связи между двумя коммутаторами, когда DTP отключен, транкинг на каждой из сторон настраивается вручную.</span></div></li></ul><div style="margin: 0mm 0mm 2.11mm; text-indent: 0mm; min-height: 6pt;"><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">Как правило, проще всего перевести порты с обеих концов канала либо в режим on, либо в режим off. Но если порт на одном из концов канала переведен в режим on или desirable, то порт, находящийся на другом конце, автоматически приступает к формированию магистрального канала, поскольку для всех портов, способных поддерживать магистральный канал (портов Ethernet со скоростью 100 Мбит/с или более высокой скоростью), по умолчанию предусмотрен режим auto</span><a href="https://ru.bmstu.wiki/DTP_%28Dynamic_Trunking_Protocol%29%20%5Cl%20cite_note-1" style="text-indent: 0mm; min-height: 6pt; vertical-align: super; font-size: smaller; color: rgb(36, 93, 193); font-family: Arial; text-decoration: underline;">[1]</a><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(37, 37, 37); font-family: Arial;">.</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial; font-weight: bold;">CDP</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;"> (англ. </span><span style="min-height: 15pt; font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial; font-weight: bold;">Cisco</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;"> Discovery Protocol)</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">CDP</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> (</span><a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA%20%5Co%20%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%20%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">англ.</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> </span><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;; font-style: italic;">Cisco Discovery Protocol</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">) — проприетарный протокол </span><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI%20%5Co%20%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%20OSI" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">второго уровня</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">, разработанный компанией </span><a href="https://ru.wikipedia.org/wiki/Cisco_Systems%20%5Co%20Cisco%20Systems" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">Cisco Systems</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">, позволяющий обнаруживать подключённое (напрямую или через устройства первого уровня) сетевое оборудование Cisco, его название, версию </span><a href="https://ru.wikipedia.org/wiki/Cisco_IOS%20%5Co%20Cisco%20IOS" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">IOS</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> и IP-адреса. Поддерживается многими устройствами компании, почти не поддерживается сторонними производителями.</span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; min-height: 9pt;"><span style="text-indent: 0mm; min-height: 9pt; font-size: 14pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;; font-weight: bold;">Получаемая информация включает в себя типы подключённых устройств, интерфейсы устройства, к которым подключены соседние устройства, интерфейсы, использующиеся для создания соединений, а также модели устройств.</span></div><div style="margin: 4.22mm 0mm 1.06mm; text-indent: 0mm; min-height: 10pt;"><span style="text-indent: 0mm; min-height: 10pt; font-size: 12pt; font-family: Georgia;">Техническое описание</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">Устройство посылает </span><a href="https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BA%D0%B0%D1%81%D1%82%20%5Co%20%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">мультикаст</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">-анонс (advertisement) на </span><a href="https://ru.wikipedia.org/wiki/MAC-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%20%5Co%20MAC-%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">MAC-адрес</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> 01-00-0c-cc-cc-cc. В конфигурации по умолчанию анонсы рассылаются каждые 60 секунд на порты </span><a href="https://ru.wikipedia.org/wiki/Ethernet%20%5Co%20Ethernet" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">Ethernet</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">, </span><a href="https://ru.wikipedia.org/wiki/Frame_Relay%20%5Co%20Frame%20Relay" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">Frame Relay</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> и </span><a href="https://ru.wikipedia.org/wiki/ATM%20%5Co%20ATM" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">ATM</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">. Каждое устройство, понимающее анонсы, сохраняет полученную информацию в CDP-таблице и позволяет посмотреть её по команде </span><span style="min-height: 15pt; font-size: 12pt; background: rgb(248, 249, 250); font-family: &quot;Courier New&quot;;">show cdp neighbors</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">, и более детально по команде </span><span style="min-height: 15pt; font-size: 12pt; background: rgb(248, 249, 250); font-family: &quot;Courier New&quot;;">show cdp entry устройство</span><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">. Если устройство трижды не прислало анонс (при значениях по умолчанию — 3 минуты (180 секунд)), оно удаляется из таблицы.</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">В анонсах также содержится информация о времени жизни пакета (Time To Live — </span><a href="https://ru.wikipedia.org/wiki/Time_to_live%20%5Co%20Time%20to%20live" style="min-height: 15pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">TTL</a><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">) или времени удержания информации (holdtime). Последний параметр определяет время, в течение которого будет храниться CDP информация, прежде чем она будет уничтожена.</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">Протокол работает на канальном уровне и позволяет двум системам получить информацию друг о друге даже в том случае, если они используют различные протоколы сетевого уровня.</span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; min-height: 7pt;"><span style="text-indent: 0mm; min-height: 7pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;">Протокол CDP обеспечивает получение информации о каждом соседнем устройстве путём передачи информации в формате </span><a href="https://ru.wikipedia.org/wiki/TLV%20%5Co%20TLV" style="text-indent: 0mm; min-height: 7pt; font-size: 12pt; color: rgb(11, 0, 128); font-family: &quot;Times New Roman&quot;; text-decoration: underline;">TLV</a><span style="text-indent: 0mm; min-height: 7pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Times New Roman&quot;;"> (Type Length Value — запись тип — длина — значение). Записи TLV — это блоки информации, внедрённые в CDP анонсы. Значения TLV конкретного устройства включают в себя такую информацию:</span></div><ul style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt; list-style-type: disc;"><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;">Идентификатор устройства;</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;">Номер и тип локального интерфейса;</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;">Время удержания информации (время, по истечении которого записи из CDP-таблицы удаляются);</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: Arial;">Тип устройства (маршрутизатор, коммутатор, сетевой мост и т.д.);</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Физическую платформу устройства (модель подключенного устройства, например, Сisco 2961);</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Номер и тип удаленного интерфейса;</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Доменное имя VTP (только в случае использования протокола CDPv2);</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div style="margin-top: 0pt; margin-bottom: 1pt;"><span style="font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Номер собственной сети VLAN (только в случае использования протокола CDPv2);</span></div></li><li style="margin-left: 16pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; font-size: 10pt;"><div><span style="font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Информацию о дуплексности соединения (только в случае использования протокола CDPv2).</span></div></li></ul><div style="margin: 4.22mm 0mm 1.06mm; text-indent: 0mm; min-height: 10pt;"><span style="text-indent: 0mm; min-height: 10pt; font-size: 12pt; font-family: Georgia;">Безопасность</span></div><div style="margin: 0mm 0mm 2.11mm; text-indent: 0mm; min-height: 6pt;"><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">Руководства по безопасности требуют отключения протокола CDP на интерфейсах, выходящих за защищённый периметр, так как передаваемая информация (например, версия IOS) может использоваться для подготовки атаки через уязвимость конкретной версии IOS. Выключение производится командой </span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; background: rgb(248, 249, 250); font-family: &quot;Courier New&quot;;">no cdp run</span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;"> глобально, </span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; background: rgb(248, 249, 250); font-family: &quot;Courier New&quot;;">no cdp enable </span><span style="text-indent: 0mm; min-height: 6pt; font-size: 10pt; color: rgb(34, 34, 34); font-family: Arial;">для интерфейса.</span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div><span style="font-style: italic; font-weight: bold; text-decoration-line: underline;">Протоколы, интерфейсы и сервисы</span> сокет - единственный интерфейс транспортного уровня в стеке протколов TCP/IP. Через этот интерфейс можно получить доступ ксервисам двух типов:надёжной и ненадёжной доставке данных. </div><div><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="font-style: italic; font-weight: bold; line-height: 108%; text-decoration: underline;">NAT Network Address Translation</span><span style="line-height: 108%;"> - трансляция сетевых адресов. Чаще всего используется, чтобы засенить айпи адрес внутренней(частной) сети в айпи адреса внешней сети (Интернет). Создано с целью преодоления нехватки адресов IPv4. Статический NAT -  отображение один к одному - нужно иметь столько же внешних адресов, сколько и компьютеров. Такое бывает редко. Чаще всего это используется для соединения сетей двух организаций, где также используются частные адреса и возможны конфликты адресов. Динамический NAT - отображение внутренних адресов на группу внешних адресов(меньшую), они используются попеременно по надобности. Чаще всего же используется вариант : отображение внутренних адресов на один внешний адрес. Преобразование реализуеься с пом. т.н. NAT таблицы, к-рая нах-тся внутри устройства NAT. Использует комбинацию IP-адрес + порт. На картинке ниже внешний порт сгенерирован случайно. Когда приходит ответ, производится поиск комбинации внешнего айпи и порта и туда шлётся инфа(перед этим у пакета происходит соответственная замена адресов. </span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="line-height: 108%;"><img src="Evernote001.enex_files/Снимок экрана (23).png" type="image/png" data-filename="Снимок экрана (23).png" width="361"/><img src="Evernote001.enex_files/Снимок экрана (24).png" type="image/png" data-filename="Снимок экрана (24).png" width="428"/></span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="line-height: 108%;">Преимущества: преодоление нехватки IPv4, легко развернуть и использовать, структура сети скрывается от внешнего мира. Недостатки: нарушается фундаментальный принцип построения айпи сетей: каждый компьютер может соединиться с любым другим; нет возможности подключиться к компьютерам во внутренней сети из внешнего мира; некоторые прикладные протоколы работают неправлильно(FTP), т.к. были созданы давно с расчётом на возможность подсоединения к любым другим компьютерам. FTP нужно два соединения - для соединения и для передачи данных. Соединение для передачи данных обычно устанавливается с сервером. Если клиент нах-тся за устр-вом NAT. то сервер FTP не может установить с ним соединение для передачи данных; также плохо работают протоколы, не устанавливающие соединения, т.к. не могут сохранить запись в таблице NAT на всё время жизни соединения; нет единого стандарта NAT, а есть много разных вариантов, поддерживающихся разными производителями оборудования и ПО.    Решение проблем: статическое отображение(требуется несколько внешних айпишников); статическое отображение портов: порт 80 - внутренний адрес ВЕБ-сервера и порт 80. порт 25 - внутренний адреспочтового сервера и порт 25, порт 21 - внутренний адрес FTP-сервера и порт 21; Технология NAT Traversal: позволяет устанавливать соединение с компьютерами во внутренней сети, RFC и другие варианты, Используется VoIP приложениями(Skype). NAT реализуется маршрутизаторами, межсетевыми экранами и другими сетевыми устройствами.</span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="font-style: italic; font-weight: bold; line-height: 108%; text-decoration: underline;">Межсетевые экраны; Прикладной уровень; Система доменных имён DNS; Протокол DNS; Типы записей DNS; Протокол HTTP; постояннон соединение в HTTP; Кэширование в HTTP; Электронная почта; Протокол SMTP; Протокол POP3; Протокол IMAP; Протокол FTP; Заключение.</span><span style="line-height: 108%;"> </span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm; line-height: 108%;"></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="text-indent: 0mm; line-height: 108%;"> </span></div></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="text-indent: 0mm; line-height: 108%;">Чтобы перезагрузить роутер cisco: сначала exit, чтобы выйти из режима</span> Router(config-if)#, потом exit, чтобы выйти из режима Router(config)#, потом <span style="text-indent: 0mm; line-height: 108%;">router#reload. То же самое со свичом, только тоже в режим с хештегом войти: enable. На роутере войти в режим </span>Router(config)# - команда config. <span style="background-color: rgb(233, 234, 214); font-size: 14.6667px; color: rgb(48, 48, 48); font-variant-caps: normal; font-variant-ligatures: normal;">Отключить поиск в системе DNS:</span> <span style="background-color: rgb(233, 234, 214); font-size: 14.6667px; white-space: pre-wrap; color: rgb(70, 27, 126);">(config)# no ip domain-lookup. Посмотреть инфу по сетевой карте и прочим: ipconfig, ipconfig/all</span> <span style="background-color: rgb(233, 234, 214); font-size: 14.6667px; white-space: pre-wrap;">. на роутере: &gt; show interfaces g0/1; &gt; show arp; </span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">Ст 81 Шерстнева: Если адреса подсетей:</span><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">172.16.0.0, </span><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">172.16.1.0, </span><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">172.16.2.0,</span><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">172.16.3.0</span><span style="font-size: 14.6667px; white-space: pre-wrap; background-color: rgb(233, 234, 214);">. маски подсетей все 255.255.255.0, то хранится ли где-нибудь маска всей сети 255.255.252.0? И как понять адреса последних ТП в подсетя</span><span style="background-color: rgb(233, 234, 214); font-size: 14.6667px; white-space: pre-wrap; text-indent: 0mm;">х: 172.16.0.140, 172.16.1.133, 172.16.2.119, 172.16.3.126? Как они получены? Там надо было создать 518 точек вроде...</span></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Настройка роутера в GNS3:</span> перейти из # в (config)# : <span style="text-decoration: underline;">conf t</span>; перейти в (config-if)# : <span style="text-decoration: underline;">int fa0/0</span> (походу конфигурация конкретно интрефейса 0/0); Moscow(config-if)#<span style="text-decoration: underline;">ip address 192.168.1.1 255.255.255.0</span> - назначили айпишник и маску; <span style="text-decoration: underline;">end</span> - выход из конфига к #; <span style="text-decoration: underline;">wr mem</span> - сохранение изменеий(айпи и маска)? ; <span style="text-decoration: underline;">show run</span> - покажет сохранённые айпишники, маски и т.п.; список команд на хосте : <span style="text-decoration: underline;">?</span>;  <span style="text-decoration: underline;">ip ?</span> - покажет команды для айпи;<span style="text-decoration: underline;"> ip 192.168.1.2/24 192.168.1.1</span> - настройка айпи хоста и роутера(gateway) одновременно? да. просто прописали гейтвей для этого хоста; <span style="text-decoration: underline;">arp</span> - показывает арп-таблицу на хосте и сколько ей осталось жить(обычно 110 с лишним секунд); на роутере: <span style="font-style: italic; font-weight: bold; text-decoration: underline;">ip dhcp ?</span> - покажет команды для dhcp; вообще для начала динамической настройки на роутере установили статический айпишник... <span style="text-decoration: underline;">ip dhcp pool DHCP</span> - перешли в режим R1(dhcp-config)#(из R1(config)); <span style="text-decoration: underline;">network 192.168.2.0 255.255.255.0</span> раздаём сетку 192.168.2.0 255.255.255.0; <span style="text-decoration: underline;">default-router 192.168.2.1</span> - дефолтный маршрут; <span style="text-decoration: underline;">ip dhcp</span> - на хосте по идее должно получить автоматичесий айпишник, но у меня не находит dhcp server; подключил другой комп, на нём сработало, эффект: DDORA IP 192.168.2.2/24 GW 192.168.2.1; после этого можно пропинговать первый комп: PC3&gt; <span style="text-decoration: underline;">ping 192.168.1.2</span></div><div>192.168.1.2 icmp_seq=1 timeout</div><div>192.168.1.2 icmp_seq=2 timeout</div><div>84 bytes from 192.168.1.2 icmp_seq=3 ttl=63 time=21.195 ms</div><div>84 bytes from 192.168.1.2 icmp_seq=4 ttl=63 time=15.082 ms</div><div>84 bytes from 192.168.1.2 icmp_seq=5 ttl=63 time=17.157 ms</div><div><br/></div><div><span style="text-decoration: underline;">trace 192.168.1.2</span> - трейс до первого компьютера. Но автор говорит - &quot;отлично&quot;, хотя в результате выдано:</div><div>trace to 192.168.1.2, 8 hops max, press Ctrl+C to stop</div><div>1   192.168.2.1   10.137 ms  9.237 ms  9.050 ms</div><div>2   *192.168.1.2   19.196 ms (ICMP type:3, code:3, Destination port unreachable)</div><div><br/></div><div><span style="text-decoration: underline;">save</span> - сохранить конфигурацию на ПК; <span style="text-decoration: underline;">copy running-config startup-config</span> - сохранение конфигурации в роутере(вроде как то же, что <span style="text-decoration: underline;">wr mem</span>); сохраняются проекты пока плохо, поэтому отключаю nvidia experience, dragon хрень и т.п; Если комп загружается быстрее роутера, то по DHCP он не успевает получить айпишник, поэтому надо ещё раз вводить <span style="text-decoration: underline;">ip dhcp</span>; </div><div>В GNS3 отсутствует возможность эмулировать коммутаторы... но есть встроенный в gns коммутатор(чисто программный, без командной строки циско, коммутатор 2-го уровня без настроек). Во многих случаях его фуекционала достаточно. А также есть другие пути: рассмотрим позже. </div><div>Настройка VLAN: правой мышью на свич, configure, double click on needed port, VLAN numericUp to choose the needed VLAN number, add, Apply, Ok. Ping the nodes to check if they're not reacheable from different virtual nets. These switches don't support STP! You shuold avoid loops. Чтобы проложить путь из роутера к роутеру в другой сети нужно прописать путь в таблице маршрутизации: <span style="text-decoration: underline;">ip route 10.255.7.0(удалённый роутер) 255.255.255.0 10.255.6.1</span>(соседний роутер, через который нужно идти) всё это в режиме conf t. Здесь маска применяется к первому адресу(назначения). Причём получается первым адресом указывать только всю сеть, иначе показывает ошибку &quot;Inconsistent address mask&quot; or  route... Похоже надо маску подбирать... Или просто в каждом роутере записи делать только для сети. Сначала не пинговалось, но это похоже потому, что надо было и в обратныую сторону(с роутера назначения) указать путь, чтобы подтверждение пинга могло вернуться. <span style="text-decoration: underline; font-weight: bold;">show ip route</span> - показать таблицу маршрутизации роутера; Чтобы начать отслеживать трафик wireshark-ом нужно проавой кнопкой кликнуть по интерфейсу на топологии и выбрать &quot;<u>Start capture</u>&quot; . <span style="-en-paragraph:true;">Как получить доступ к консоли конфигурирования маршрутизатора CISCO (продемонстрируйте). В</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">GNS</span> <span style="-en-paragraph:true;">для начала маршрутизатор нужно загрузить:</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">edit</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">prefrences</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">dynamips</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">ios</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">routers</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">new</span> <span style="-en-paragraph:true;">-&gt; выбираем файл образа устройства. Например</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">c</span><span style="-en-paragraph:true;">3725-</span><span style="mso-ansi-language: EN-US;-en-paragraph:true;">adventerprisek</span><span style="-en-paragraph:true;">9-</span><span style="mso-ansi-language: EN-US;-en-paragraph:true;">mz</span><span style="-en-paragraph:true;">.124-15.</span><span style="mso-ansi-language: EN-US;-en-paragraph:true;">T</span><span style="-en-paragraph:true;">14.</span><span style="mso-ansi-language: EN-US;-en-paragraph:true;">bin</span><span style="-en-paragraph:true;">, устанавливаем его. Ставим галочку, разрешающую связь с сетевой картой устройства:</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">Virtual</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">box</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">template</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">edit</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">network</span> <span style="-en-paragraph:true;">-&gt;</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">Allow</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">GNS</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">to</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">use</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">any</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">configured</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">VirtualBox</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">adapter</span><span style="-en-paragraph:true;">. Перетаскиваем устройство в проект, включаем, правой кнопкой мыши –</span> <span style="mso-ansi-language: EN-US;-en-paragraph:true;">Console</span><span style="-en-paragraph:true;">. WinServer2016 password: winServ1; Вместо Ctrl + Alt + Del в виртуал боксе надо жать правый Ctrl + Del; </span></div><div><span style="-en-paragraph:true;"><br/></span></div><div><span style="-en-paragraph:true;"><u style="font-weight: bold; font-style: italic;">Windows Server 2016:</u> <u>route print</u> - просмотр таблицы маршрутизации; <u>ipconfig</u> - попроще; <u>route /p(делает изменение persistent, т.е. постоянным,оно сохранится даже после перезагрузки сервера)</u></span></div><div><br/></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Делаю конфигурацию &quot;роутер на палочке&quot;(это как коммутатор L3 получается распознает айпишники)</span>. Распределил сеть из 4-х компов по 2-м VLAN. К пятому порту коммутатора подключил роутер. Этот порт должен работать в режиме TRUNK. Конфигурирую свич: два раза по пятому порту, чтобы напротив Port появилось 5;  напротив Type выставляю dot1q (trunk); Номер ВЛАН-а не трогаю, оставляю по умолчанию 1; apply, Ok; стартую роутер; поднимаю физ. интерфейс fa0/0 роутера: conf t, int fa0/0, no shutdown, exit; int fa0/0.2(создал саб-интерфейс для второго ВЛАН-а)(выглядит: R1(config-subif)#); encapsulation dot1Q 2 - указал, что это второй влан; ip address 192.168.2.1 255.255.255.0 - повесил айпи адрес; no shutdown; exit. Т.о. на роутер вешаю айпи-адрес, являющийся шлюзом для наших компьютеров(в подсети 2); конфигугрирую для ВЛАН 3: fa0/0.3; encapsulation dot1Q 3; ip address 192.168.3.1 255.255.255.0; no shutdown; end; wr mem; ещё раз выставляю dot1q для пятого порта(надо так, чтобы вместо access было dot1q(в таблице); проверяю шлюз по умолчанию ПК1: 192.168.2.1; пингуется; Теперь пингуем соседнюю виртуальную подсеть: ping 192.168.3.2  и она пингуется, т.к. мы эти сети объединили роутером. </div><div> </div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">2-й способ использования коммутатора в GNS3(некое подобие cisco 3560 или 3750)</span> схема роутер + EtherSwitch module = L3 Switch. Т.о. получаем 16 доп. портов, к-рые можем настраивать как порты L2 или L3 коммутатора. Всё просто. Плюсы метода: хороший L2 функционал, наличие L3 функционала, малое потребеление системных ресурсов. Минусы: не сохраняется конфигурация, не совместим с встроенным свичем GNS3, нестабильность. Не факт, что мне это надо. Пока пауза.</div><div><br/></div><div><span style="text-decoration: line-through;">поставил локалхост 5190... много чего ещё вероятно произошло... но теперь открываеи сохранённые проекты.</span></div><div><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Технология открытия файлов проектов в GNS3; подключения виртуал бокса к сети: </span> после запуска дождатьсяпоявления окна создания нового проекта, там выбрать recent и нужный проект. Загрузится. Чтобы соединить пустой контейнер со свичем, надо правой кнопкой на контейнере, configure, network, allow GNS to use any configured VirtualBox adapter.</div><div><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><span style="font-style: italic; font-weight: bold; text-decoration: underline;">Коммутаторы третьего уровня модели OSI(L3):</span> Ip-маршрутизация; агрегирование коммутаторов уровня доступа; используются в качестве коммутаторов уровня распределения; высокая производительность, низкая стоимость по сравнению с маршрутизаторами. Ни в коем случае не заменяют маршрутизаторы. Работают для маршрутизации трафика внутри сети, но не наружу. </div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"><br/></div><div style="margin: 0mm 0mm 2.81mm; text-indent: 0mm;"></div></span>
</div></body></html> 